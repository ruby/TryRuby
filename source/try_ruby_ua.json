{"1":{"lang":"UA","title":"Є 30 хвилин? Дай Ruby шанс, і він тебе здивує!","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Ruby – це мова програмування з Японії, яка створила передумови для революції у веб-розробці.</p>\n\n<p>Краса Ruby в її балансі між простотою і можливостями.</p>\n\n<p>Ти можеш ввести код на Ruby в редакторі і використовувати кнопки для навігації:</p>\n\n<ul>\n<li><strong>Run</strong> &rarr; Виконати код, що знаходиться в редакторі</li>\n<li><strong>Copy</strong> &rarr; Вставити/скопіювати приклад коду в редактор</li>\n<li><strong>Next</strong> &rarr; Перейти до наступного уроку</li>\n<li><strong>Back</strong> &rarr; Повернутися до попереднього уроку</li>\n</ul>\n\n<div class=\"foxes\">Натисни <strong>Next</strong> для початку навчання.</div>\n","load_code":""},
"2":{"lang":"UA","title":"Використання редактора","chapter":"N","answer":"^\\d{1,}$","ok":"Чудово! Ти використовуєш математику. Бачив як з'явилася відповідь?","error":"Введи 2 + 6","text":"<p>Набирай свій код на Ruby у вікні редактора знизу, потім натисни кнопку <strong>Run</strong> і подивися як це працює!</p>\n\n<p>Наприклад, спробуймо порахувати простий вираз:</p>\n\n<pre><code>2 + 6\n</code></pre>\n\n<p>Результат програми повинен відображатися у вікні вгорі. На наступному рядку буде відображатися, наскільки добре ти впорався.</p>\n\n<blockquote>\n<p>Також ти можеш натиснути кнопку <strong>Copy</strong> щоб скопіювати код з прикладу в редактор.</p>\n</blockquote>\n","load_code":""},
"3":{"lang":"UA","title":"Числа і математика","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Добре","error":"","text":"<p>Ruby розуміє числа і математичні операції. Спробуй дещо інше, наприклад:</p>\n\n<pre><code>4 * 10\n5 - 12\n30 / 4\n</code></pre>\n","load_code":""},
"4":{"lang":"UA","title":"Виводимо результат інакше","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"Чудово!","error":"","text":"<p>Помітив, що коли ти набираєш більше одного виразу, виводиться результат тільки останнього.\nЩо ж відбувається?</p>\n\n<blockquote>\n<p>Для більш зручного використання цього сайту, я наказав Ruby копіювати результат нашої програми в поле виведення вгорі.\nТож коли ти набираєш вираз, результат виводиться на екран.\n<strong>Але тільки останній результат.</strong> І тільки якщо досі нічого не відображалося.</p>\n</blockquote>\n\n<p>Тож коли ти ввів кілька виразів, Ruby показав результат тільки останнього виразу.</p>\n\n<p>Звичайно, Вам хочеться побачити результат всіх! Додай <strong>puts</strong> перед кожним виразом (розділяючи пробілом).\nPuts означає: <em>&lsquo;вивести щось на екран&rsquo;</em>.</p>\n\n<p>Спробуй:</p>\n\n<pre><code>puts 4 * 10\nputs 5 - 12\nputs 30 / 4\n</code></pre>\n\n<p>А тепер видали puts з останньої формули і подивись, що станеться.</p>\n","load_code":""},
"5":{"lang":"UA","title":"Назви своє ім'я!","chapter":"N","answer":"[a-zA-Z]{1,1}","ok":"Чудово, ти створив рядок з літер свого імені","error":"","text":"<p>Звісно комп&lsquo;ютери зручні для розрахунків. Але спробуймо щось іще. Хочеш вивести своє ім&#39;я навпаки?</p>\n\n<p>Для початку набери своє ім&#39;я в лапках як тут:</p>\n\n<p>&ldquo;Андрій&rdquo;</p>\n","load_code":""},
"6":{"lang":"UA","title":"Скажи своє ім'я навпаки","chapter":"N","answer":"\\w+","ok":"оводуЧ","error":"","text":"<p>Рядок є набором символів, які комп&lsquo;ютер може обробляти. Уявіть, що букви, які знаходяться в рядку, – як білизна на мотузці, а лапки – прищіпки, які тримають кінці цієї мотузки. Лапки позначають початок і кінець.</p>\n\n<p>Щоб отримати ім&#39;я задом наперед, набери:</p>\n\n<pre><code>&quot;Андрій&quot;.reverse\n</code></pre>\n\n<p>(І не забудь точку!)</p>\n","load_code":""},
"7":{"lang":"UA","title":"Підрахунок літер","chapter":"N","answer":"^\\d+$","ok":"Так. Довжина рядка це також 'метод'","error":"","text":"<p>Ти вже спробував <strong>метод</strong> reverse на своєму імені! Уклавши ім&#39;я в лапки, ти створив рядок. Потім ти викликав метод reverse, який працює з рядками і розгортає їх задом наперед.</p>\n\n<p>А тепер погляньмо, скільки літер у твоєму імені:</p>\n\n<pre><code>&quot;Андрій&quot;.length\n</code></pre>\n","load_code":""},
"8":{"lang":"UA","title":"На повторі","chapter":"N","answer":"(\\w+)","ok":"Приємно познайомитись! Приємно познайомитись! Приємно познайомитись!","error":"","text":"<p>Зараз тобі напевно цікаво, навіщо все це потрібно.</p>\n\n<p>Що ж, я впевнений, ти хоч раз помічав на сайті напис: <strong>Ваш пароль занадто короткий!</strong></p>\n\n<p>Диви, деякі програми використовують простий код <strong>.length</strong>.</p>\n\n<p>Поглянь ще. Помнож своє ім&#39;я на 5.</p>\n\n<pre><code>&quot;Андрій&quot; * 5\n</code></pre>\n","load_code":""},
"9":{"lang":"UA","title":"Підсумки #1 Вже","chapter":"Y","answer":"NoMethodError|undefined","ok":"Ні, неможливо розгорнути число. Натисни 'next'","error":"","text":"<p>Погляньмо, що ти вже вивчив за першу хвилину.</p>\n\n<h3>Редактор коду</h3>\n\n<p>Можна набирати код в редакторі і отримувати відповідь у вікні виводу.\n(Майже) всі програми видають відповідь.</p>\n\n<h3>Числа і рядки</h3>\n\n<p>Числа і рядки це математичні та текстові об&lsquo;єкти Ruby.</p>\n\n<h3>Методи</h3>\n\n<p>Ти спробував методи зі слів англійською мовою reverse і length.\nА також символьний метод множення: * <strong>Метод означає дію!</strong></p>\n\n<p>В цьому суть твого навчання. Беремо базові речі, граємося ними і перетворюємо їх на щось нове.\nПочуваєшся комфортно? Сподіваюсь що так!</p>\n\n<h3>Добре</h3>\n\n<p>Спробуймо дещо незвичайне. Спробуй розгорнути число в інший бік:</p>\n\n<pre><code>40.reverse\n</code></pre>\n","load_code":""},
"10":{"lang":"UA","title":"Зупинись, ти здурів!)","chapter":"N","answer":"^\\d{1,}$","ok":"Розгорнути можна тільки рядки","error":"","text":"<p>Не можна розгорнути число задом наперед. Ти, звісно, можеш тримати монітор перед дзеркалом, але розгортання числа просто не має сенсу.</p>\n\n<p>Ruby виведе повідомлення з помилкою. Ruby каже тобі, що не існує методу reverse для чисел.</p>\n\n<p>Хіба може спробувати перетворити число 40 на рядок для початку:</p>\n\n<pre><code>40.to_s.reverse\n</code></pre>\n","load_code":""},
"11":{"lang":"UA","title":"Яблука відрізняються від апельсинів","chapter":"N","answer":"\\[\\]","ok":"Добре, це пустий список.","error":"","text":"<p>А числа відрізняються від рядків.</p>\n\n<p>У той час як використання методів може бути застосовано до всіх об&lsquo;єктів Ruby, деякі методи працюють тільки з певними типами даних.\nАле ти можеш перетворити один тип на інший, використовуючи методи типу &ldquo;to&rdquo;</p>\n\n<ul>\n<li><strong>to_s</strong> перетворює на рядки</li>\n<li><strong>to_i</strong> перетворює на число</li>\n<li><strong>to_a</strong> перетворює на масив</li>\n</ul>\n\n<p><strong>Що таке масив?!</strong></p>\n\n<p>Масив – це просто список. Набери 2 квадратні дужки:</p>\n\n<pre><code>[]\n</code></pre>\n","load_code":""},
"12":{"lang":"UA","title":"Черга по квитки","chapter":"N","answer":"^\\[([-\\.\\d]+)(\\s*,\\s*[-\\d\\.]+){3,}\\]$","ok":"Чудесно","error":"Спробуй додати четверте число до списку","text":"<p>Списки (масиви) зберігають елементи <strong>в певній послідовності</strong>.</p>\n\n<p>Схоже на чергу по квитки. Ти стоїш за кимось і навіть не мрієш його відштовхнути або пересунути, чи не так? Також хлопчина за тобою, ти пильно слідкуєш за кожним його рухом.</p>\n\n<p>Ось ще список. Номери лотерейних квитків:</p>\n\n<pre><code>[12, 47, 35]\n</code></pre>\n\n<p>Спробуй додати число до масиву. Набери кому і число після 35. Пробіл не обов&#39;язковий.</p>\n","load_code":""},
"13":{"lang":"UA","title":"Перший піднімає руку","chapter":"N","answer":"^47$","ok":"Ok","error":"","text":"<p>Список номерів лотерейних квитків. А який номер максимальний?</p>\n\n<p>Спробуй:</p>\n\n<pre><code>[12, 47, 35].max\n</code></pre>\n","load_code":""},
"14":{"lang":"UA","title":"Сховаємо список","chapter":"N","answer":"^\\[(\\d+)(,\\s*\\d+){2,}\\]$","ok":"Заховано!","error":"","text":"<p>Добре. Але ж незручно набирати список кожного разу, коли він потрібен, так?</p>\n\n<p>Збережімо наші номери лотереї таким чином:</p>\n\n<pre><code>ticket = [12, 47, 35]\n</code></pre>\n","load_code":""},
"15":{"lang":"UA","title":"Тепер введи ticket","chapter":"N","answer":"\\[(\\d+(, )?){2,}\\]","ok":"Видобуто!","error":"","text":"<p>А зараз набери:</p>\n\n<pre><code>ticket\n</code></pre>\n","load_code":"ticket = [12, 47, 35]"},
"16":{"lang":"UA","title":"Збережено й заховано","chapter":"N","answer":"\\[12, 35, 47\\]","ok":"Ти відсортував список","error":"","text":"<p>Ти поклав список номерів в <strong>змінну</strong> з назвою ticket.\nАле будь-яке інше ім&#39;я, як <strong>andriilist</strong>, теж згодиться.</p>\n\n<p>Займаючись програмуванням, ти помітиш, що це, переважно, робота зі змінними.</p>\n\n<p>Впорядкуймо список лотерейних квитків?</p>\n\n<p>Використай:</p>\n\n<pre><code>ticket.sort!\n</code></pre>\n\n<p>Ти мав простий список. Ти його відсортував. Змінна ticket теж змінилася.\nТи помітив, що у методу <strong>sort!</strong> на кінці стоїть великий знак оклику?\nТак Ruby повідомляє нам, що змінна ticket буде змінена не лише в цьому виразі, а й, також, в пам&#39;яті.\nНічого надзвичайного, просто запам&#39;ятай!</p>\n","load_code":"ticket = [12, 47, 35]"},
"17":{"lang":"UA","title":"Елементи","chapter":"N","answer":"^(12|35|47)$","ok":"Ok","error":"Майже","text":"<p>Ми зберегли числа в змінну, а як їх отримати назад?</p>\n\n<p>Ми вже бачили, як ми можемо отримати максимальний елемент, використовуючи метод <strong>max</strong>.\nТакож ти можеш отримати <strong>first</strong> (перший) або <strong>last</strong> (останній) елемент списку.\nА що коли ти хочеш отримати якийсь конкретний елемент?</p>\n\n<h3>[ ]</h3>\n\n<p>Ruby використовує [], щоб націлитися на елемент.\nКвадратні дужки дуже поширені в Ruby.\nВони означають: &ldquo;Я шукаю ____&rdquo;, Готовий, цілься!</p>\n\n<p>Отримай всі номери зі списку:</p>\n\n<pre><code>puts ticket [0]\nputs ticket [1]\nputs ticket [2]\n</code></pre>\n\n<p>Чому ми використовуємо [0], [1], [2]?</p>\n\n<p>А не [1], [2] чи [3]? Це якийсь японський дзен? Ні, в багатьох мовах програмування відлік йде з нуля. Це не тільки особливість Ruby.</p>\n\n<blockquote>\n<p>Невелике нагадування: ти можеш використовувати кнопку <strong>Copy</strong>.</p>\n</blockquote>\n","load_code":"ticket = [12, 47, 35]"},
"18":{"lang":"UA","title":"Підсумки #2 Що тут у нас?","chapter":"Y","answer":"\\w+","ok":"Чи є хоч якась рима?)","error":"","text":"<p>Зараз поглянемо, як минула твоя друга хвилина:</p>\n\n<h3>Помилки</h3>\n\n<p>Якщо ти спробуєш розгорнути число чи якусь іншу дурницю, Ruby скаже тобі про це.</p>\n\n<h3>Масиви</h3>\n\n<p>Масиви – це списки, що зберігають елементи в певній послідовності.\nМи вже знаємо, як створити масив і отримати елементи з нього.</p>\n\n<h3>Змінні</h3>\n\n<p>Змінні зберігають значення і дають їм імена. Ми використали знак рівності щоб зробити це.\nЯк тут: ticket = [14, 37, 18].</p>\n\n<h3>2/8</h3>\n\n<p>Всього тут 8 розділів. 2 вже позаду! Не дуже й складно, так?</p>\n\n<p>Змінімо напрямок. Я люблю поезію і поклав трохи в змінну poem, тож поглянь. Набери:</p>\n\n<pre><code>puts poem\n</code></pre>\n","load_code":"poem = \"Моя канапка випала у мене з рук. \\nІ моя канапка полетіла на Місяць. \\nТа коли я побачив її в телевізорі, \\nРазом з прапором України на кометі Галлея, \\nТоді я найбільше хотів її з'їсти\\n\""},
"19":{"lang":"UA","title":"На жаль, тобі не подобається така поезія","chapter":"N","answer":"(toast){0}","ok":"Чудово","error":"Все одно канапка","text":"<p>Все гаразд. Всі ми різні. Редагуй цей шматочок як хочеш. Замість канапки може бути грушка або що завгодно.\nСпробуй це, щоб побачити новий варіант поеми:</p>\n\n<p>poem.gsub(&ldquo;канапка&rdquo;, &ldquo;грушка&rdquo;)</p>\n\n<p>Метод <strong>gsub</strong> це скорочення global substitute (замінник). Він замінить всі збіги &ldquo;канапка&rdquo; на &ldquo;грушка&rdquo;.</p>\n","load_code":"prev"},
"20":{"lang":"UA","title":"Готовий, цілься!","chapter":"N","answer":"^\\nитсї'з її вітох (.+)","ok":"Звісно, увесь віршик розвернутий задом наперед","error":"","text":"<p>Питання для тебе: що станеться?</p>\n\n<pre><code>poem.reverse\n</code></pre>\n","load_code":"prev"},
"21":{"lang":"UA","title":"Занадто багато слів навпаки","chapter":"N","answer":"^\\[\"Тоді я найбільше (.+)","ok":"Так, майже те що треба","error":"","text":"<p>Що ж, вся наша поема стала задом наперед, слово за словом! Але ж я всього лише хотів зробити це для рядків.\nПеремісти перший рядок на кінець, а останній на початок. Тобто навпаки, але не так.</p>\n\n<p>Ось як:</p>\n\n<pre><code>poem.lines.reverse\n</code></pre>\n","load_code":"prev"},
"22":{"lang":"UA","title":"Ще трохи методів в ланцюжок","chapter":"N","answer":"^Тоді я найбільше (.+)","ok":"Прекрасно, друже!<br/>Метод join взяв масив рядків і з'єднав їх в один рядок'.","error":"","text":"<p>Що ти бачиш тут? Що сталося? Ти набрав <strong>poem.lines.reverse</strong> і що сталося?</p>\n\n<p>Дві речі. Перше: ти розбив віршик на рядки, за допомогою методу lines, і отримав масив з них.</p>\n\n<p>Потім ти розгорнув цей список задом наперед і розгорнув кожен рядок. От і все!</p>\n\n<p>Додамо ще один метод в кінець:</p>\n\n<pre><code>puts poem.lines.reverse.join\n</code></pre>\n\n<p>Комбінування методів таким чином називається <strong>ланцюжком методів</strong>.</p>\n","load_code":"prev"},
"23":{"lang":"UA","title":"Підсумки #3 Тут і зараз","chapter":"Y","answer":"\\{\\}","ok":"Ти створив порожній словник!","error":"","text":"<h3>Знак оклику</h3>\n\n<p>Методи можуть мати знак оклику (як і знак питання) в своєму імені.\nВони тут для більш зрозумілого пояснення, що вони роблять. Нічого страшного.</p>\n\n<h3>Маніпуляції з рядками</h3>\n\n<p>Пошук і зміна рядків</p>\n\n<h3>Ланцюжки</h3>\n\n<p>Ланцюжки методів дозволяють зробити набагато більше. Розбити віршик, розгорнути його, об&lsquo;єднати в рядок:\n<strong>poem.lines.reverse.join</strong></p>\n\n<p>На цьому етапі, ти можеш подивитися всі методи для рядків тут <a href=\"http://ruby-doc.org/core/classes/String.html\" target=\"_blank\">here</a>.</p>\n\n<p>Спробуй декілька з них: poem.downcase або poem.swapcase</p>\n\n<h2>Готовий?</h2>\n\n<p>Коли ви будеш готовий рухатися далі, набери:</p>\n\n<p>books = {}</p>\n","load_code":"prev"},
"24":{"lang":"UA","title":"Порожній словник","chapter":"N","answer":"^(splendid|quite_good|mediocre|quite_not_good|abysmal)$","ok":"Yes that's a new review","error":"Use one of splendid, quite_good, mediocre, quite_not_good, abysmal.<br/>Don't forget the colon","text":"<p>Ми створили порожній <strong>словник (hash)</strong>. Словник – це як масив, тільки у кожного елемента є ім&#39;я.</p>\n\n<blockquote>\n<p>Примітка перекладача: в україномовному співтоваристві слово hash перекладається як словник. Якщо Array перекладають як масив, то Hash – словник, інколи просто &gt;хеш. Назва hash походить від hash-функції, на основі якої працює словник, і яка дозволяє дуже швидко знаходити елемент за ключем (ім&#39;ям). Але щоб використовувати словники, нам це знати не обов&#39;язково.</p>\n</blockquote>\n\n<p>Ми збираємося записати кілька мініатюрних відгуків в наш новий словник. Ось наша рейтингова система:</p>\n\n<ul>\n<li>:splendid &rarr; витвір мистецтва</li>\n<li>:quite_good &rarr; так, сподобалося</li>\n<li>:mediocre &rarr; посередньо</li>\n<li>:quite_not_good &rarr; загалом погано</li>\n<li>:abysmal &rarr; жах</li>\n</ul>\n\n<p>Щоб оцінити книгу, додай назву в квадратних дужках і постав оцінку після знака дорівнює. Наприклад:</p>\n\n<pre><code>books[&quot;Фарбований Лис&quot;] = :splendid\n</code></pre>\n\n<blockquote>\n<p>Зараз, я вважаю за необхідне сказати, що всі уроки в TryRuby відокремлені один від одного.\nТож якщо ти вирішив пофестивалити і зробити дуже багато відгуків, то використовувати їх ти зможеш тільки в цьому уроці.\nЯкщо ж хочеш використати свої відгуки і в наступному уроці, то ти повинен скопіювати їх і вставити.\nНе турбуйся про це, в кожному уроці є багато запрограмованих речей для тебе щоб гратися.</p>\n</blockquote>\n","load_code":"books = {}"},
"25":{"lang":"UA","title":"Ще кілька простих відгуків","chapter":"N","answer":"[3-9]","ok":"Бачиш, метод length працює з рядками, списками і словниками.","error":"","text":"<p>Продовжуй, заповни хеш відгуками. А якщо хочеш побачити весь список, просто набери: puts books</p>\n\n<p>Знову ж, можливі оцінки: :splendid, :quite<em>good, :mediocre, :quite</em>not_good і :abysmal.</p>\n\n<p>Ці оцінки не є рядками. Коли ти ставиш двокрапку перед простим словом, ти отримуєш <strong>символ (Symbol)</strong>. Символ є дешевшим за рядок (з точки зору комп&lsquo;ютерної пам&#39;яті). Тож якщо використовуєш слово знову і знову в своїй програмі, використовуй символ. Замість того, щоб мати тисячі копій цього слова в пам&#39;яті, Ruby буде зберігати символ тільки <strong>один раз</strong>.</p>\n\n<p>Що важливіше, символ каже нам, що це не просто якесь слово, а таке, що має значення у нашій програмі.</p>\n\n<blockquote>\n<p>Примітка перекладача: в англійській мові є два слова: Symbol і Char, і обидва перекладаються українською як &ldquo;символ&rdquo;.\nВ контексті Ruby Symbol правильно було б перекласти як &ldquo;ідентифікатор&rdquo;, але використовують слово символ.\nТому якщо в контексті Ruby ти почуєш &ldquo;символ&rdquo;, то швидше за все це Symbol, ідентифікатор, який записується як :good, і є оптимізованим для пам&#39;яті рядком.</p>\n</blockquote>\n\n<p>Введи ще 2 відгуки, використовуй books.length, щоб дізнатися, скільки відгуків в словнику:</p>\n\n<pre><code>books[&quot;Сутінки. Сага.&quot;] = :abysmal\nbooks[&quot;Фарбований Лис&quot;] = :mediocre\n\nputs books\n\nputs books.length\n</code></pre>\n","load_code":"books = {\"Фарбований лис\" => :splendid}"},
"26":{"lang":"UA","title":"Стоп, невже я засудив Фарбованого Лиса?)","chapter":"N","answer":"^(splendid|quite_good|mediocre|quite_not_good|abysmal)$","ok":"Мені сподобалося","error":"","text":"<p>Однією з чудесних особливостей Ruby є те, що імена часто використовуються повторно, тож менша кількість імен, які тобі треба запам&#39;ятати.</p>\n\n<p>Раніше ми витягли елементи з масиву за допомогою числа:\n<strong>puts ticket[1]</strong>.</p>\n\n<p>Для словника це працює однаково, але ми використовуємо не число, щоб отримати елемент, а ім&#39;я (ключ).</p>\n\n<p>Отже, якщо хочеш подивитися один зі своїх старих відгуків, знову введи назву в квадратних дужках. Але не пиши знак дорівнює. Ось так:</p>\n\n<pre><code>puts books[&quot;Фарбований лис&quot;]\n</code></pre>\n","load_code":"books = {\"Фарбований Лис\" => :splendid, \"Сутінки. Сага.\" => :abysmal, \"Хоббіт\" => :mediocre}"},
"27":{"lang":"UA","title":"Словники це пари","chapter":"N","answer":"^\\[\".*\"\\]","ok":"Ти знайшов ключі","error":"","text":"<p>Пам&#39;ятай, що словники не зберігають елементи в послідовності. Це не їхнє завдання.\nВони створюють пару з двох елементів: <strong>ключ (key)</strong> і <strong>значення (value)</strong></p>\n\n<p>У твоїх відгуках, назва книги це ключ, а оцінка – значення.</p>\n\n<p>Якщо ж хочеш побачити всі назви книг які ти оцінив, введи:</p>\n\n<pre><code>books.keys\n</code></pre>\n\n<p>Також спробуй використати .values замість .keys.</p>\n","load_code":"prev"},
"28":{"lang":"UA","title":"Ти суворий критик?","chapter":"N","answer":"\"mediocre\"","ok":"Ти створив свій власний рейтинг книжок","error":"","text":"<p>Ти пишеш суворі, несправедливі відгуки? Порахуємо їх в новому словнику <strong>ratings</strong>:</p>\n\n<p>Тепер ми можемо їх порахувати. Набери:Then, okay, now let&rsquo;s count up your reviews. Just stay with me. Type:</p>\n\n<pre><code>ratings = Hash.new {0}\n\nbooks.values.each { |rate|\n  ratings[rate] += 1\n}\n\nputs ratings\n</code></pre>\n\n<p>Прямою лінією в коді є символ pipe, ймовірно, розташований зверху клавіші Enter на твоїй клавіатурі.</p>\n\n<p>Цей рядок += 1 означає: збільшити значення на одиницю.</p>\n\n<p>Не турбуйся, якщо не розумієш всього, що тут відбувається. Все буде ясно пізніше.</p>\n","load_code":"books = {\"Фарбований Лис\" => :splendid, \"Сутінки. Сага.\" => :abysmal, \"Хоббіт\" => :mediocre, \"Голодні ігри\" => :mediocre}"},
"29":{"lang":"UA","title":"Підрахунок","chapter":"N","answer":"\\w+","ok":"Будьмо!","error":"","text":"<p>Одна з приголомшливих речей, яку ми щойно використали це <strong>блок (block)</strong>.\nМи вивчимо їх докладніше на цьому й наступному уроці. Та загалом блок – це трохи коду на Ruby, оточеного фігурними дужками.</p>\n\n<p>Спробуй створити інший блок:</p>\n\n<pre><code>5.times{ print &quot;Будьмо!&quot; }\n</code></pre>\n\n<p>Блоки завжди прив&#39;язані до методів. Як метод <strong>times</strong>, який бере блок і запускає код знову і знову. (В нашому прикладі: п&lsquo;ять разів.)</p>\n","load_code":""},
"30":{"lang":"UA","title":"Є хвилинка?","chapter":"N","answer":"^[0-9]$","ok":"Дуже вчасно!","error":"Виконай від 0 до 9","text":"<p>Як ми бачили в першому прикладі з блоком (при підрахунку оцінок), ми можемо передати змінну блокові.\nЗначення, яке <strong>вставляється</strong> визначається методом, який запускає блок.</p>\n\n<p>Змінні, які <strong>приймає</strong> блок, поміщаються в ім&#39;я змінної на початку блоку, між двома символами pipe: |</p>\n\n<p>Спробуймо це за допомогою цього блоку:</p>\n\n<p>5.times {|time|\n     puts time\n}</p>\n\n<p>Тут метод <strong>.times</strong> посилає значення змінній <strong>|time|</strong>. Але майте на увазі, що ця змінна відома тільки всередині блоку.</p>\n\n<blockquote>\n<p>Ти помітив, що можеш розділити код на декілька рядків? Так їх потім простіше читати.</p>\n</blockquote>\n","load_code":""},
"31":{"lang":"UA","title":"Підводячи підсумки #4","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Цей урок був дещо довшим і ти, ймовірно, витратив на три хвилини більше на його вивчення:</p>\n\n<h3>Словники</h3>\n\n<p>Найпростіший приклад словника: <strong>{}</strong></p>\n\n<h3>Символи</h3>\n\n<p>Крихітні але ефективні кодові слова з двокрапкою, наприклад: <strong>:splendid</strong></p>\n\n<h3>Блоки</h3>\n\n<p>Шматочки коду, які можна прив&#39;язати до багатьох методів Ruby.\nОсь код, який ми використовували щоб створити таблицю оцінок:<br>\n<strong>books.values.each { |rate| ratings[rate] += 1 }</strong></p>\n\n<h3>Далі</h3>\n\n<p>На наступних уроках ми ще глибше зануримося в методи.</p>\n","load_code":""},
"32":{"lang":"UA","title":"Бути чи не бути","chapter":"N","answer":"","ok":"","error":"","text":"<p>Одна маленька деталь, яку ми не обговорили – це аргументи методів.\nПам&#39;ятаєш, як ми змінили вміст поеми, використовуючи цей метод:\n<strong>poem.gsub(&ldquo;канапка&rdquo;, &ldquo;грушка&rdquo;)</strong></p>\n\n<p>Метод gsub вимагає два аргументи, які ми передали як рядки в круглих дужках.\n<strong>Аргументи кажуть методові, що саме йому робити.</strong></p>\n\n<h3>Круглі дужки</h3>\n\n<p>Насправді, в більшості випадків Ruby не проти, якщо ти пропустиш дужки. Таким чином, це теж спрацює:\n<strong>poem.gsub &ldquo;канапка&rdquo;, &ldquo;грушка&rdquo;</strong></p>\n\n<p>Ми також вже використовували й інший метод з параметром. Багато разів. Але це не так очевидно:</p>\n\n<pre><code>puts &quot;Hello&quot;\nputs(&quot;Hello&quot;)\n</code></pre>\n\n<p>Так, <strong>puts</strong> це теж метод. Хочеш писати puts з круглими дужками або без – для Ruby байдуже,\nале варіант без дужок простіше читати і трохи економить час набору коду!</p>\n\n<blockquote>\n<p>Висновок полягає в тому, що ти можеш робити все, що завгодно з круглими дужками, поки код читається красиво.</p>\n</blockquote>\n\n<h3>Тож бути чи не (бути)?</h3>\n\n<p>Хочеш ще трохи Шекспіра? Читай далі.</p>\n","load_code":"poem = \"Моя канапка випала у мене з рук. \\nІ моя канапка полетіла на Місяць. \\nБла, бла, бла\\n\""},
"33":{"lang":"UA","title":"Приборкання норовливої","chapter":"N","answer":"^tame","ok":"Добре добре!","error":"","text":"<p>Ти вже знаєш, як використовувати Ruby. Я маю на увазі, ти вже збагнув основи.\nДалі тобі потрібно вивчити більше методів і спробувати більш складні блоки.\nАле ми ще дещо не обговорили. Створення власних методів. Займімося цим.</p>\n\n<p>У той час, як Ruby має вбудовані методи (такі, як puts, sort, times),\nти вже можеш писати свої власні методи. Навіщо? На це є дві причини:</p>\n\n<h3>Зробити свою програму коротшою</h3>\n\n<p>Якщо ти використовуєш один і той же код більш ніж в одному місці, тобі буде набагато простіше,\nякщо виділити його в новий метод. Це зробить код коротшим.</p>\n\n<h3>Зробити свій код кращим для читання</h3>\n\n<p>Припустімо, що твоя програма повинна робити багато різних речей.\nТи <strong>можеш</strong> записати весь код в один довгий текст. Але було б дуже складно прочитати і зрозуміти цей код пізніше.</p>\n\n<p>Замість цього ти маєш розбити свій код на методи і дати кожному з них зрозуміле ім&#39;я. Подякуєш собі пізніше.</p>\n\n<p>Отже, як ми визначаємо метод? Ось так:</p>\n\n<pre><code>def tame( number_of_shrews )\nend\n</code></pre>\n","load_code":""},
"34":{"lang":"UA","title":"В Ruby, Def Leppard означає: визначити метод Leppard","chapter":"N","answer":"^tame","ok":"Tame is not lame","error":"","text":"<p>В Ruby, Def Leppard означає: визначити метод Leppard\nДобре, ти це зробив. Ти створив свій власний метод. Почав з def, за яким іде ім&#39;я методу. І список аргументів, які будуть потрібні методові. Це не дуже страшно і небезпечно! Все, що нам потрібно зробити, це заповнити його кодом на Ruby і закінчити з end.</p>\n\n<p>Ось код:</p>\n\n<pre><code>def tame( number_of_shrews )\n  number_of_shrews.times {\n    puts &quot;Tamed a shrew&quot;\n  }\nend\n</code></pre>\n\n<blockquote>\n<p><strong>P.S.</strong><br>\nЯкщо ти не знаєш цю назву, Def Leppard це відома Британська рок-група <a href=\"http://en.wikipedia.org/wiki/Def_Leppard\" target=\"_blank\">Def Leppard</a></p>\n</blockquote>\n","load_code":""},
"35":{"lang":"UA","title":"Достиглий плід твоєї праці","chapter":"N","answer":"^Приборкав норовливу","ok":"Так їм!","error":"","text":"<p>Новий метод народжено. Спробуємо його використати:</p>\n\n<pre><code>tame 5\n</code></pre>\n","load_code":"def tame(number_of_shrews);number_of_shrews.times{puts \"Tamed a shrew\"};end;"},
"36":{"lang":"UA","title":"Давай і бери","chapter":"N","answer":"\\d+","ok":"Так","error":"","text":"<p>Більшість методів не тільки вимагають введення деяких параметрів, але й <strong>повернуть щось назад</strong>.\nЯ трохи змінив наш метод, щоб він повернув нам значення. Спробуй:</p>\n\n<pre><code>def tame( number_of_shrews )\n  number_of_shrews.times {\n    puts &quot;Tamed a shrew&quot;\n  }\n  return number_of_shrews\nend\n\nputs tame(3)\n</code></pre>\n\n<h3>Результат</h3>\n\n<p>А оскільки ти вже настільки просунутий і компетентний, ще одна порада: можеш опустити слово <strong>return</strong> з останнього рядка методу.\nRuby автоматично поверне останнє значення, яке використовувалося в методі.</p>\n\n<p>Так ми можемо змінити останній рядок просто на: <strong>number_of_shrews</strong>.</p>\n\n<p>Але оскільки метод <strong>.times</strong> також повертає <em>number_of_shrews</em> ми можемо стерти останній рядок цілком.\nТак що наш новий метод робить те, що ми від нього хотіли!</p>\n","load_code":""},
"37":{"lang":"UA","title":"Привіт, хто тут? Підсумки #5 вітають тебе!","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Відмінно, відмінно, відмінно!\nСупер, супер, сууууупер!</p>\n\n<p>Ось що ми ще дізналися:</p>\n\n<h3>Методи</h3>\n\n<p>Методи можуть бути визначені за допомогою <strong>def</strong> та мають ім&#39;я.\nМетоди роблять нашу програму коротшою і простішою для читання.</p>\n\n<h3>Параметри</h3>\n\n<p>Методи можуть мати параметри.</p>\n\n<h3>Значення, що повертаються</h3>\n\n<p>Методи (майже) завжди повертають якесь значення.</p>\n\n<h2>А зараз</h2>\n\n<p>Бути чи не (бути) не є для тебе більше великим питанням. Ти готовий почитати ще трохи Шекспіра?</p>\n","load_code":""},
"38":{"lang":"UA","title":"Світ – наша мушля","chapter":"N","answer":"^\\{\\\"William","ok":"Добре. Але важко читати.","error":"","text":"<p>Досі ти запускав програми, які використовують тільки те, що ти набирав сам. Це класно, але зараз епоха інтернету, а значить можна використовувати ці дані.</p>\n\n<p>Багато, багато веб-сайтів в мережі, а значить у всіх них можна запросити інформацію. Наприклад: ця посилання дасть вам всі останні <a href=\"http://news.google.com/news/section?q=ruby&output=rss\" target=\"_blank\">Новини з Гугла</a> по тематиці Ruby.</p>\n\n<p>Ваш бравзер, можливо, відобразить це красиво. Але якщо поглянеш на сирцевий код (натисни: ctrl-U), то побачиш складний текст в форматі <strong>rss</strong>.</p>\n\n<h3>Формати</h3>\n\n<p>Всього існує дуже багато форматів зі складними назвами в мережі, такі як: html, xml та json. Ага, навіть цей веб-сайт використовує декілька.</p>\n\n<p>Я підготував для тебе метод, який вибере список повних робіт Вільяма Шекспіра ​​з Інтернету. (Не хвилюйся, насправді все це скачується з того ж сервера, на якому розміщений мій сайт, тому ми нікого не турбуємо.)</p>\n\n<p>Отримай дані за допомогою:</p>\n\n<pre><code>get_shakey\n</code></pre>\n","load_code":"def get_shakey;JSON.parse(\"{\\\"William Shakespeare\\\": {\\\"1\\\": {\\\"title\\\": \\\"The Two Gentlemen of Verona\\\", \\\"finished\\\": 1591},\\\"2\\\": {\\\"title\\\": \\\"The Taming of the Shrew\\\", \\\"finished\\\": 1591},\\\"3\\\": {\\\"title\\\": \\\"Henry VI, Part 2\\\", \\\"finished\\\": 1591},\\\"4\\\": {\\\"title\\\": \\\"Henry VI, Part 3\\\", \\\"finished\\\": 1591},\\\"5\\\": {\\\"title\\\": \\\"Henry VI, Part 1\\\", \\\"finished\\\": 1592},\\\"6\\\": {\\\"title\\\": \\\"Titus Andronicus\\\", \\\"finished\\\": 1592},\\\"7\\\": {\\\"title\\\": \\\"Richard III\\\", \\\"finished\\\": 1593},\\\"8\\\": {\\\"title\\\": \\\"Edward III\\\", \\\"finished\\\": 1593},\\\"9\\\": {\\\"title\\\": \\\"The Comedy of Errors\\\", \\\"finished\\\": 1594},\\\"10\\\": {\\\"title\\\": \\\"Love's Labour's Lost\\\", \\\"finished\\\": 1595},\\\"11\\\": {\\\"title\\\": \\\"Love's Labour's Won\\\", \\\"finished\\\": 1596},\\\"12\\\": {\\\"title\\\": \\\"Richard II\\\", \\\"finished\\\": 1595},\\\"13\\\": {\\\"title\\\": \\\"Romeo and Juliet\\\", \\\"finished\\\": 1595},\\\"14\\\": {\\\"title\\\": \\\"A Midsummer Night's Dream\\\", \\\"finished\\\": 1595},\\\"15\\\": {\\\"title\\\": \\\"King John\\\", \\\"finished\\\": 1596},\\\"16\\\": {\\\"title\\\": \\\"The Merchant of Venice\\\", \\\"finished\\\": 1597},\\\"17\\\": {\\\"title\\\": \\\"Henry IV, Part 1\\\", \\\"finished\\\": 1597},\\\"18\\\": {\\\"title\\\": \\\"The Merry Wives of Windsor\\\", \\\"finished\\\": 1597},\\\"19\\\": {\\\"title\\\": \\\"Henry IV, Part 2\\\", \\\"finished\\\": 1598},\\\"20\\\": {\\\"title\\\": \\\"Much Ado About Nothing\\\", \\\"finished\\\": 1599},\\\"21\\\": {\\\"title\\\": \\\"Henry V\\\", \\\"finished\\\": 1599},\\\"22\\\": {\\\"title\\\": \\\"Julius Caesar\\\", \\\"finished\\\": 1599},\\\"23\\\": {\\\"title\\\": \\\"As You Like It\\\", \\\"finished\\\": 1600},\\\"24\\\": {\\\"title\\\": \\\"Hamlet\\\", \\\"finished\\\": 1601},\\\"25\\\": {\\\"title\\\": \\\"Twelfth Night\\\", \\\"finished\\\": 1601},\\\"26\\\": {\\\"title\\\": \\\"Troilus and Cressida\\\", \\\"finished\\\": 1602},\\\"27\\\": {\\\"title\\\": \\\"Sir Thomas More\\\", \\\"finished\\\": 1604},\\\"28\\\": {\\\"title\\\": \\\"Measure for Measure\\\", \\\"finished\\\": 1604},\\\"29\\\": {\\\"title\\\": \\\"Othello\\\", \\\"finished\\\": 1604},\\\"30\\\": {\\\"title\\\": \\\"All's Well That Ends Well\\\", \\\"finished\\\": 1605},\\\"31\\\": {\\\"title\\\": \\\"King Lear\\\", \\\"finished\\\": 1606},\\\"32\\\": {\\\"title\\\": \\\"Timon of Athens\\\", \\\"finished\\\": 1606},\\\"33\\\": {\\\"title\\\": \\\"Macbeth\\\", \\\"finished\\\": 1606},\\\"34\\\": {\\\"title\\\": \\\"Antony and Cleopatra\\\", \\\"finished\\\": 1606},\\\"35\\\": {\\\"title\\\": \\\"Pericles, Prince of Tyre\\\", \\\"finished\\\": 1608},\\\"36\\\": {\\\"title\\\": \\\"Coriolanus\\\", \\\"finished\\\": 1608},\\\"37\\\": {\\\"title\\\": \\\"The Winter's Tale\\\", \\\"finished\\\": 1611},\\\"38\\\": {\\\"title\\\": \\\"Cymbeline\\\", \\\"finished\\\": 1610},\\\"39\\\": {\\\"title\\\": \\\"The Tempest\\\", \\\"finished\\\": 1611},\\\"40\\\": {\\\"title\\\": \\\"Cardenio\\\", \\\"finished\\\": 1613},\\\"41\\\": {\\\"title\\\": \\\"Henry VIII\\\", \\\"finished\\\": 1613},\\\"42\\\": {\\\"title\\\": \\\"The Two Noble Kinsmen\\\", \\\"finished\\\": 1614}}}\");end;"},
"39":{"lang":"UA","title":"Шляхетні родичі","chapter":"N","answer":"^Два шляхетні родичі$","ok":"Так значно краще","error":"","text":"<p>Отже, тепер у нас є список п&lsquo;єс з Інтернету. Список був в форматі json. На щастя для нас Ruby люб&#39;язно надає метод перетворення даних json на словник Ruby. Метод <em>get_shakey</em> зробив це за нас.</p>\n\n<p>Але оскільки структура json-даних зберігається в словнику, її трохи важко читати. Тож ми напишемо метод для показу п&#39;єс.</p>\n\n<p>Якщо ти уважно вивчиш список п&#39;єс, то побачиш, що він має наче гніздову структуру.\n(Це досить поширено в даних, які ти отримуєш з Інтернету.) Виглядає це так:</p>\n\n<ul>\n  <li>&ldquo;William Shakespeare&rdquo;\n  <ul>\n      <li>&ldquo;1&rdquo;\n      <ul>\n        <li>&ldquo;title&rdquo;: &ldquo;The Two Gentlemen of Verona&rdquo;</li>\n        <li>&ldquo;finished&rdquo;: 1591</li>\n      </ul>\n      </li>\n      <li>&ldquo;2&rdquo;\n      <ul>\n        <li>&ldquo;title&rdquo;: &ldquo;The Taming of the Shrew&rdquo;</li>\n        <li>&ldquo;finished&rdquo;: 1591</li>\n      </ul>\n      </li>\n      <li>&hellip;</li>\n  </ul>\n  </li>\n</ul>\n\n<p>Щоб перерахувати п&#39;єси, нам спочатку потрібно отримати доступ до верхнього елементу словника &ldquo;Вільям Шекспір&rdquo; по його назві.\nПотім ми повинні <strong>iterate (&ldquo;крокувати&rdquo;)</strong> по кожному елементу за ним.</p>\n\n<p>Ruby має метод для ітерації. Він називається <strong>each</strong>. Ми бачили це раніше, коли створювали нашу систему рейтингу книжок.</p>\n\n<p>Все, що повертає метод <strong>each</strong>, передається блокові:</p>\n\n<pre><code>s = get_shakey\n\ns[&quot;William Shakespeare&quot;].each { |key, val|\n  puts val[&quot;title&quot;]\n}\n</code></pre>\n","load_code":"prev"},
"40":{"lang":"UA","title":"Всі разом","chapter":"N","answer":"^4$","ok":"Так, Шекспір написав 4 п'єси' в 1591","error":"Відповідь для року 1591 має бути 4","text":"<p>Тепер припустімо, що ми хочемо знати імена і кількість п&lsquo;єс, написаних Шекспіром протягом певного року.</p>\n\n<p>Ruby дозволяє нам <strong>виводити</strong> значення зі словника.\nМетод select використовує блок, який дозволяє нам визначити, що вибрати і повернути знайдене.</p>\n\n<p>Потім ми можемо використовувати результати, які повертаються через <strong>select</strong> в методі <strong>each</strong>, як і раніше, просто додаючи його після блоку select. Це ще один приклад ланцюжка методів, який ми бачили раніше, коли розгортали віршик задом наперед.</p>\n\n<p>Я підготував для тебе метод <strong>count_plays</strong>. Побачимо, чи зможеш ти порахувати кількість п&#39;єс, написаних Шекспіром в <strong>1591</strong>:</p>\n\n<pre><code>def count_plays(year)\n  s = get_shakey\n\n  s[&quot;William Shakespeare&quot;]\n    .select { |k, v|\n      v[&quot;finished&quot;] == year\n    }.each { |key, val|\n      puts val[&quot;title&quot;]\n    }.count\nend\n\nputs count_plays(0)\n\nТи помітив, що я додав метод count в самому кінці кожного методу. Так ми отримаємо значення, що повертається методу __count\\_plays__.\n\nЄ й інший спосіб вибудовування ланцюжка. Бачиш самотній рядок __s = get_shakey__.\nТи можеш додати __[&quot;William Shakespeare&quot;].select{ |k, v|__ в кінець get_shakey (але не обов&#39;язково тут).\n</code></pre>\n","load_code":"prev"},
"41":{"lang":"UA","title":"Все добре, що добре закінчується","chapter":"N","answer":"Все добре, що добре закінчується","ok":"True","error":"Використовуй 1605 як другий параметр","text":"<p>Добре, ми отримали деякі дані з Інтернету, ми вибрали те, що хотіли, і роздрукували це.\nЩо ще поліпшити? Ми могли б надрукувати результати трохи гарніше. Як додати рік і вирівняти назви і роки.</p>\n\n<p>Це означає потрібно друк декількох значень на одному рядку. Ruby має зручний спосіб зробити це.\nЦе схоже на друк рядка типу: <strong>puts &ldquo;Привіт, мене звуть Андрій&rdquo;</strong>. Але замість літерного значення <strong>Андрій</strong> ми використовуємо значення змінної.</p>\n\n<p>Спочатку заміни <strong>Андрій</strong> на <strong>#{}</strong>. Якщо Ruby бачить символ #, а за ним символ {то шукає змінні між цими дужками}.\nТож ми можемо використати: <strong>&ldquo;Привіт, мене звуть #{name}&rdquo;</strong>.</p>\n\n<p>Змінимо наш код трохи:</p>\n\n<pre><code>def print_plays(year_from, year_to)\n  get_shakey[&quot;William Shakespeare&quot;]\n    .select { |k, v|\n      year_from &lt;= v[&quot;finished&quot;] &amp;&amp;\n      year_to   &gt;= v[&quot;finished&quot;]\n    }.each { |k, v|\n      puts &quot;#{v[&quot;title&quot;].ljust(30)} #{v[&quot;finished&quot;]}&quot;\n    }\nend\nprint_plays(1600, 1605)\n</code></pre>\n\n<p>Я додав <strong>.ljust(30)</strong> до заголовку. В такому випадку заголовок має відступ мінімум 30 символів. Так рік виглядає охайніше :)</p>\n\n<p>Подивися, чи зміниться вихід програми так, щоб вона показувала такі п&lsquo;єси: <strong>1600 -&gt; As You Like It</strong></p>\n\n<p><strong>Все добре, що добре занчується?</strong> Гей, ми ще не закінчили, але кінець вже близько!</p>\n","load_code":"prev"},
"42":{"lang":"UA","title":"Якби я знав, як прийняти рішення","chapter":"N","answer":"","ok":"","error":"","text":"<p>Робити вибір в житті буває важко, але не в Ruby.\nТут є зручні способи приймати рішення.</p>\n\n<pre><code>if 1 &lt; 2\n  puts &quot;Це правда: 1 менше 2&quot;\nend\n</code></pre>\n\n<p>Ключове слово <strong>if (якщо)</strong>. If можна ставити і до, і після методу, як тут:</p>\n\n<pre><code>puts &quot;Це правда: 1 менше 2&quot; if 1 &lt; 2\n</code></pre>\n\n<p><strong>If</strong> це метод, який вимагає 1 параметра. Цим параметром може бути будь-який вираз, який ти хочеш перевірити.\nРезультат виразу може бути <strong>true (правда)</strong> або <strong>false (брехня)</strong>. Ось кілька прикладів:</p>\n\n<pre><code>5     &lt;= 10     # =&gt; true\n&#39;abc&#39; == &#39;def&#39;  # =&gt; false\ntrue            # =&gt; true\n123456          # =&gt; true\n0               # =&gt; true\nnil             # =&gt; false\n&#39;xyz&#39;.empty?    # =&gt; false\n&#39;a&#39; &gt; 5         # =&gt; error:\n                # comparison of String with\n                # Numeric failed\n</code></pre>\n\n<p>Вираз if може мати багато видів: порівнювати значення (1 &lt; 2), змінні (a &lt; 1) і повертатися значення методів (&lsquo;xyz&rsquo;.empty?).</p>\n","load_code":""},
"43":{"lang":"UA","title":"І на останок","chapter":"N","answer":"не дорівнює 100$","ok":"Це краще","error":"Так не може бути","text":"<p>Бачиш подвійне дорівнює <strong>&lsquo;abc&rsquo; == &lsquo;def&rsquo;</strong>?</p>\n\n<p>Це <strong>==</strong> означає <strong>перевірка на рівність</strong>. Одиночне дорівнює використовується для <strong>надання значення змінній</strong>.</p>\n\n<p>Щоб трохи тебе заплутати: можеш використати присвоювання як аргумент методу if:</p>\n\n<pre><code>a = 0\n\nif a = 100\n  puts &quot;Вираз вірний, але а зараз дорівнює: #{a}&quot;\nelse\n  puts &quot;#{a} не дорівнює 100&quot;\nend\n</code></pre>\n\n<p>Поміняй = на == і подивися, що станеться.</p>\n\n<p>Я гарантую, що ти будеш часто забувати поставити подвійне дорівнює, я теж забуваю інколи.</p>\n\n<h3>Інакше (else)</h3>\n\n<p>У коді я використав else, що виконується у разі якщо <strong>if тестовий_вираз</strong> обчислюється як брехня (false).</p>\n\n<blockquote>\n<p>Більше інформації ти можеш отримати <a href=\"http://www.ruby-doc.org/core/doc/syntax/control_expressions_rdoc.html\" target=\"_blank\">тут.</a></p>\n</blockquote>\n","load_code":""},
"44":{"lang":"UA","title":"Я голодний","chapter":"N","answer":"^Я не голодний","ok":"Так","error":"Я не голодний о 10 ранку!","text":"<p>Це прекрасно, це прості речі, але пам&#39;ятай, що ти <strong>не знав Ruby</strong> всього 15 хвилин тому!</p>\n\n<p>Тож тепер об&lsquo;єднаємо всі наші отримані навички: визначимо 2 методи:</p>\n\n<pre><code>def hungry?(time_of_day_in_hours)\n  puts &quot;Я голодний&quot;\n  true\nend\n\ndef eat_an(what)\n  puts &quot;Я їм #{what}\\n&quot;\nend\n\neat_an &#39;яблуко&#39; if hungry?(14)\n\neat_an &#39;яблуко&#39; if hungry?(10)\n\nСпробуй змінити метод __hungry?__ так, щоб він друкував __&quot;Я не голодний&quot;__ і повертав false коли час буде менше 12-ї.\n</code></pre>\n","load_code":""},
"45":{"lang":"UA","title":"Підсумки #6 Ми пройшли довгий шлях","chapter":"Y","answer":"\\{\\}","ok":"Це порожній словник","error":"","text":"<p>Ти 6-го рівня Ruby клірик. Тобто відмінна робота! Підіб&lsquo;ємо підсумки:</p>\n\n<h3>Дані</h3>\n\n<p>Ти завантажив трохи даних з інтернету, пройшовся по них і вибрав значення.</p>\n\n<h3>Iterating (крокування)</h3>\n\n<p>Ти пройшов по всіх елементах словника, а також створив ланцюжок методів.</p>\n\n<h3>Гарний друк</h3>\n\n<p>І якщо цього недостатньо, то ти форматував і вивів кілька даних щоб їх було зручно прочитати людям.\n<strong>Ти зробив справжню програму!</strong></p>\n\n<h3>Якщо (If)</h3>\n\n<p>Ти навчився використовувати оператори розгалуження <strong>if</strong> та <strong>else</strong></p>\n\n<h2>Тож</h2>\n\n<p>Що може бути далі? Що ти, можливо, повинен дізнатися зараз? Ха, це найкраща частина.\nТи пройшов довгий шлях, тож пора вивчити класи. Ще два коротких уроки, і все готово.</p>\n\n<p>Раніше ми створювали словник так:</p>\n\n<pre><code>Hash.new\n</code></pre>\n","load_code":""},
"46":{"lang":"UA","title":"Не шкільний клас, а робітничий","chapter":"N","answer":"","ok":"","error":"","text":"<p>Як бачиш порожні фігурні дужки {} це скорочення для Hash.new. Метод new використовується, щоб створювати об&lsquo;єкти певного класу. Сприймай &ldquo;class&rdquo; в сенсі &ldquo;робітничий клас&rdquo; &mdash; якась особлива група, що робить одну роботу і в однакових футболках.\nДля чого використовуються класи?</p>\n\n<h3>Blurbalizer<sup>TM</sup></h3>\n\n<p>Ти маєш чудову ідею для нової програми. Це буде чергова платформа для обміну повідомленнями. Ти хочеш додаток, де люди будуть обмінюватися короткими повідомленнями. Ти називаєш ці повідомлення Blurbs<sup>TM</sup>. Blurb<sup>TM</sup> має максимальну довжину 40 символів. До роботи.</p>\n\n<h3>Де почати?</h3>\n\n<p>Ти можеш зберегти записи Blurbs<sup>TM</sup> в json-файлі, так?\nАле як би ти відстежував зміст запису і час публікації? І коли ти завантажиш файл, як він буде виглядати в Ruby?\nЦе буде словник? Або масив? Або масив масивів? Або щось інше?</p>\n\n<h3>Клас</h3>\n\n<p>Я впевнений, що ти хотів би використати клас. Ти вже знаєш деякі з них: словник (Hash), масив (Array), рядок (String).</p>\n\n<p>Створімо новий клас (нічого не повертаючи):</p>\n\n<pre><code>class Blurb\nend\n</code></pre>\n","load_code":""},
"47":{"lang":"UA","title":"Те з чого робляться додатки","chapter":"N","answer":"","ok":"","error":"","text":"<p>Ми відкрили новий Blurb<sup>TM</sup> class. клас. Чим наповнений ваш блог?\nТак, змістом! Також часом, коли Blurb<sup>TM</sup> був опублікований. І настроєм.</p>\n\n<p>Добре, тож у нас є перший рядок класу, ось решта:</p>\n\n<pre><code>class Blurb\n  attr_accessor :content, :time, :mood\nend\n</code></pre>\n\n<p>Імена класів завжди починаються з великої літери (і знову ж, нічого не повертається).</p>\n","load_code":""},
"48":{"lang":"UA","title":"Аксесори це кінцівки","chapter":"N","answer":"Blurb:","ok":"Мій перший Blurb","error":"","text":"<p>Чудово. У тебе є новий Blurb<sup>TM</sup> клас.</p>\n\n<p>У визначенні класу ти використав метод, який називається attr_accessor (аксесор).\nВзагалі є багато атрибутів класу, які так чи інакше його змінюють. Атрибути – це всього лише змінні пов&#39;язані з класом.</p>\n\n<p>Думайте так. Клас – це людина. Це людська істота у формі зірки.\nА атрибути – це її кінцівки, різні частини збираються в тіло, а інші люди можуть взяти цю людину за руку і привітатися.</p>\n\n<h3>Зараз</h3>\n\n<p>Щоб створити Blurb<sup>TM</sup> і наповнити даними напиши:</p>\n\n<pre><code>blurb1 = Blurb.new\nputs blurb1\nblurb1.content = &quot;Today Mount Hood Was Stolen!&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :content,:time,:mood;end"},
"49":{"lang":"UA","title":"Об'єкт, цей акуратний маленький пакет","chapter":"N","answer":"Blurb:","ok":"Blurb оновлено","error":"","text":"<p>А тепер змінимо атрибути нашого Blurb<sup>TM</sup>:</p>\n\n<pre><code>blurb1.time = Time.now\nblurb1.mood = :sick\n\nputs blurb1\n</code></pre>\n","load_code":"prev;blurb1=Blurb.new;blurb1.content=\"Today Mount Hood Was Stolen!\""},
"50":{"lang":"UA","title":"Прискорюємося","chapter":"N","answer":"^\\d{4}","ok":"Відмічено","error":"","text":"<p>Круто, новий додаток просто блискучий. А як щодо спростити?\nТи не захочеш ставити час свого Blurb<sup>TM</sup> кожного разу коли постиш, чи не так?</p>\n\n<p>Ти просто хочеш записати свої контент і настрій?</p>\n\n<p>Додамо метод ініціалізації <strong>initialize</strong> в наш клас.\nЦей метод буде завжди викликатися, коли ти створюєш новий Blurb<sup>TM</sup>.\nТакож ми можемо встановити максимальну довжину Blurb<sup>TM</sup> контенту в 40 символів.</p>\n\n<pre><code>class Blurb\n  attr_accessor :content, :time, :mood\n\n  def initialize(mood, content=&quot;&quot;)\n    @time    = Time.now\n    @content = content[0..39]\n    @mood    = mood\n  end\nend\n\nBlurb.new.time\n</code></pre>\n\n<p>(Цей параметр <strong>content=&ldquo;&rdquo;</strong> використовується, щоб нам було відомо, що контент це рядок і ніякий інший параметр не може ініціювати його.)</p>\n","load_code":""},
"51":{"lang":"UA","title":"Ти навчив свій додаток відкидати непотрібні речі","chapter":"N","answer":"Blurb:","ok":"Blurb додано","error":"","text":"<p>Ти помітив, як ми використовуємо символ собачки &ldquo;всередині класу&rdquo;? (@time).</p>\n\n<p><strong>Ззовні</strong> класу ми використовуємо аксесор:</p>\n\n<blockquote>\n<p><strong>blurb.time = Time.now</strong></p>\n</blockquote>\n\n<p>але <strong>всередині</strong> ми використовуємо змінні об&lsquo;єкта:</p>\n\n<blockquote>\n<p><strong>@time = Time.now</strong></p>\n</blockquote>\n\n<p>Це одне і те саме, але може використовуватися в різних місцях твоєї програми.</p>\n\n<h3>Створімо інший Blurb<sup>TM</sup></h3>\n\n<p>Коли інший Blurb<sup>TM</sup> створений, метод ініціалізації використовується для перевірки будь-якого аргументи до методу new.</p>\n\n<p>Ой, потрібно ще 2 аргументи:</p>\n\n<pre><code>Blurb2 = Blurb.new :confused, &quot;Не можу повірити, Мавнт-Худ вкрали!&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :content,:time,:mood;def initialize(mood, content=\"\");@time=Time.now;@content=content[0..39];@mood=mood;end;end;blurb1=Blurb.new(:sick,\"Today Mount Hood Was Stolen!\")"},
"52":{"lang":"UA","title":"А жирафа на місці Підсумки #7","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Ага, ти тут. І все ще вчишся.\nМи як і раніше будемо робити твій додаток реальним, але поки що погляньмо на результати, гаразд?</p>\n\n<h3>Класи</h3>\n\n<p>Все в Ruby – це об&lsquo;єкти. Класи пояснюють об&#39;єкти, як певний об&#39;єкт працює.\nНаприклад, ти створив кілька Blurb<sup>TM</sup> об&#39;єктів, а ці об&#39;єкти поводяться так само як будь-який об&#39;єкт класу Blurb.\nІншими словами: ти називаєш їх Blurb об&#39;єктами. Ти можеш використовувати класи щоб (начебто) моделювати реальне життя.  </p>\n\n<h3>Аксесори</h3>\n\n<p>Аксесори – це змінні, пов&#39;язані з класом, але використовуються ззовні об&#39;єкта.</p>\n\n<p>(blurb2.time = Time.now)</p>\n\n<h3>Змінні об&#39;єкта</h3>\n\n<p>Це те ж саме, що й аксесори, але вони використовуються <strong>всередині</strong> об&#39;єкта.\n(@time = Time.now)</p>\n","load_code":"prev;blurb2=Blurb.new :confused, \"I can not believe Mt. Hood was stolen!\""},
"53":{"lang":"UA","title":"Твій власний терен","chapter":"N","answer":"Blurbalizer:","ok":"Додаток створено","error":"","text":"<p>Гаразд, закругляймося, хлопче. Ось останній розділ епічної історії пізнання Try Ruby!\nТепер, коли у тебе є розуміння, як все це працює, як ти збираєшся його використовувати?\nТи чудова людина (один з моїх улюбленців), але тобі потрібне керівництво.</p>\n\n<h3>Закінчимо наш додаток</h3>\n\n<p>У нас є записи додатків, але може бути відсутня програма.\nЯк і раніше потрібно ім&#39;я, місце, де можна зберігати всі Blurbs<sup>TM</sup> і впорядкувати їх.</p>\n\n<p>Ми збираємося використовувати інший клас. Я дав весь код для нового класу за раз. Тільки <strong>не поспішай, вивчи його</strong>.\nЯ не поспішаю, я буду чекати тебе на наступному уроці.</p>\n\n<pre><code>class Blurbalizer\n  def initialize(title)\n    @title  = title\n    @blurbs = [] # Порожній масив\n</code></pre>\n\n<p>                     # для зберігання Blurbs\n      end</p>\n\n<pre><code>  def add_a_blurb(mood, content)\n    # The &lt;&lt; means add to the end of the array\n    @blurbs &lt;&lt; Blurb.new(mood, content)\n  end\n\n  def show_timeline\n    puts &quot;Blurbify: #{@title} has #{@blurbs.count} Blurbs&quot;\n\n    @blurbs.sort_by { |t|\n      t.time\n    }.reverse.each { |t|\n      puts &quot;#{t.content.ljust(40)} #{t.time}&quot;\n    }\n  end\nend\n\nmyapp = Blurbalizer.new &quot;The Big Blurb&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :content,:time,:mood;def initialize(mood, content=\"\");@time=Time.now;@content=content[0..39];@mood=mood;end;end"},
"54":{"lang":"UA","title":"То про що цей Blurb?","chapter":"N","answer":"Сьогодні","ok":"Додай blurbs","error":"","text":"<p>І ось результат. Ти зрозумів, що робить код у класі Blurbalizer<sup>TM</sup>?</p>\n\n<blockquote>\n<p>У Blurbalizer<sup>TM</sup> є 2 методи (add_a_blurb та show_timeline). Можеш використовувати метод поза класом, так як і з аксесорами.</p>\n</blockquote>\n\n<p>Саме час щоб почати використовувати Blurbalizer<sup>TM</sup>. Я вже завантажив кілька Blurbs<sup>TM</sup> для тебе, але можеш додати ще свій.</p>\n\n<p>Ми більше не створюємо Blurbs<sup>TM</sup> directly, безпосередньо, а використовуємо метод add_a_blurb з класу Blurbalizer<sup>TM</sup>.\nТепер ми можемо бути певні, що всі наші  Blurbs<sup>TM</sup> зберігаються в об&lsquo;єкті myapp.</p>\n\n<pre><code>myapp.add_a_blurb :moody, &quot;Додай Blurb сюди&quot;\n\nmyapp.show_timeline\n</code></pre>\n","load_code":"prev;class Blurbalizer;attr_reader :title;def initialize(title);@title=title;@blurbs=[];end;def add_a_blurb(mood, content);@blurbs << Blurb.new(mood, content);@blurbs.each {|t| t.time -= 73};end;def show_timeline;puts \"Blurbalizer: #{@title} has #{@blurbs.count} Blurbs\\n\";@blurbs.sort_by { |t| t.time}.reverse.each { |t| puts \"#{t.content.ljust(40)} #{t.time}\"};end;end;myapp = Blurbalizer.new \"The Big Blurb\";myapp.add_a_blurb :sick,\"Today Mount Hood Was Stolen!\";myapp.add_a_blurb :confused,\"I can not believe Mt. Hood was stolen!\";myapp.add_a_blurb :dazed,\"I am speechless!\";myapp.add_a_blurb :mad,\"It was stolen by a giraffe !!\";myapp.add_a_blurb :sad,\"I Left my Hoodie on the Mountain!\";myapp.add_a_blurb :mad,\"I am never going back to that mountain.\""},
"55":{"lang":"UA","title":"Про комбінування","chapter":"N","answer":":-","ok":"Moody!","error":"","text":"<p>Деякі цікаві речі можна зробити за допомогою простих частин Ruby, особливо коли ти їх поєднуєш разом в дещо нове. Тут ми маємо додаток, що складається з класу, що містить інший клас. Це називається об&lsquo;єктно-орієнтоване програмування (ООП).</p>\n\n<p>Ми приступаємо до <strong>останнього завдання</strong> на TryRuby. Якщо хочеш, то можеш додати більше цікавого в Blurbalizer<sup>TM</sup>.</p>\n\n<p>Може ти захочеш вивести усміхнений смайлик в методі <strong>show_timeline</strong>.\nТи маєш додати <em>moodify</em> метод в клас Blurb<sup>TM</sup> і потім використати цей метод в <strong>show_timeline</strong>:</p>\n\n<pre><code>class Blurb\n  attr_accessor :content, :time, :mood\n\n  def initialize(mood, content=&quot;&quot;)\n    @time    = Time.now\n    @content = content[0..39]\n    @mood    = mood\n  end\n\n  def moodify\n    if    @mood == :sad\n      return &quot;:-(&quot;\n    elsif @mood == :happy\n      return &quot;:-)&quot;\n    # Додай інший смайлик сюди\n    end\n\n    # Смайлик за замовчуванням\n    &quot;:-|&quot;\n  end\nend\n\nclass Blurbalizer\n  def initialize(title)\n    @title  = title\n    @blurbs = []\n  end\n\n  def add_a_blurb(mood, content)\n    @blurbs &lt;&lt; Blurb.new(mood, content)\n  end\n\n  def show_timeline\n    puts &quot;Blurbalizer: #{@title} has #{@blurbs.count} Blurbs&quot;\n\n    @blurbs.sort_by { |t|\n      t.time\n    }.reverse.each { |t|\n      puts &quot;#{t.content.ljust(40)} #{t.time}&quot;\n    }\n  end\nend\n\nmyapp.show_timeline\n</code></pre>\n","load_code":"prev"},
"56":{"lang":"UA","title":"Підсумки #8 Розслабся, ти добре постарався!","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Цей останній розділ потрібен, щоб дати тобі кілька вказівок про те, як ти можеш використовувати Ruby.</p>\n\n<p>Якщо тобі сподобалося, то можеш продовжити в <a href=\"/playground\">TryRuby Playground</a>\nабо завантажити та встановити Ruby:\n<a href=\"https://www.ruby-lang.org/en/downloads/\" target=\"_blank\">ruby-lang.org</a></p>\n\n<p>Коли встановиш Ruby, створи новий файл <em>my_first_progam.rb</em>, використовуючи текстовий редактор, додай трохи коду,\nпотім відкрий термінал або командний рядок і набери:</p>\n\n<pre><code>ruby my_first_progam.rb\n</code></pre>\n\n<p>Існує багато (вільних) середовищ розробки, які поєднують редактор коду, переглядач файлів і середовище Ruby.\nУ професіоналів попитом користуються Ruby Mine, VS Code, Atom, Sublime Text, Vim.</p>\n\n<h2>Святкуй!</h2>\n\n<p>Ти дійсно заслуговуєш двошаровий торт з подвійною глазур&#39;ю і музиканта, що грає на одній з тих крутих подвійних гітар.\nТи закінчив, ти дійсно зробив це! Не сумнівайтеся в собі! Продовжуй вивчати цю прекрасну мову програмування – Ruby!</p>\n\n<h2>Більше інформації</h2>\n\n<p>На цьому сайті є ще статті, в яких ти можеш знайти щось корисне для себе.</p>\n","load_code":"def ruby(f);puts \"Go to www.ruby-lang.org to download Ruby\";end;class K;attr_reader :rb;end;my_first_progam=K.new"}}