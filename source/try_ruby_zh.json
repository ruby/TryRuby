{"1":{"lang":"ZH","title":"有30分钟无事可做? 来尝试一下Ruby吧!","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Ruby是一门来自日本，并在软件开发领域引起了革命的编程语言。</p>\n\n<p>Ruby的美在于其语法简洁的同时保证了语言的强大。</p>\n\n<p>你可以在编辑器中输入Ruby代码，用这些按钮来使用网站。</p>\n\n<ul>\n<li><strong>Run</strong> &rarr; 在编辑器中执行代码</li>\n<li><strong>Copy</strong> &rarr; 将示例代码粘贴至编辑器</li>\n<li><strong>Next</strong> &rarr; 前往下一节课</li>\n<li><strong>Back</strong> &rarr; 回到上一节课</li>\n</ul>\n\n<div class=\"foxes\">点击 <strong>Next</strong> 开始学习.</div>\n","load_code":""},
"2":{"lang":"ZH","title":"如何使用编辑器","chapter":"N","answer":"^\\d{1,}$","ok":"不错！简单的数学，看到结果是如何显示的了吗？","error":"在编辑器中输入 2 + 6","text":"<p>编辑器窗口可以输入Ruby代码，点击 <strong>RUN</strong> 按钮，然后就可以运行了！\n比如，输入一些数学，就像：</p>\n\n<pre><code>2 + 6\n</code></pre>\n\n<p>程序的输出会在OUTPUT窗口显示。\n并且会有一行字告诉你你做的怎么样。</p>\n\n<blockquote>\n<p>或者你可以直接按 <strong>Copy</strong> 按钮，代码会自动输入。</p>\n</blockquote>\n","load_code":""},
"3":{"lang":"ZH","title":"数字与数学","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"不错","error":"","text":"<p>Ruby能够识别数字和数学符号，试试看其他的算式：</p>\n\n<pre><code>4 * 10\n5 - 12\n30 / 4\n</code></pre>\n","load_code":""},
"4":{"lang":"ZH","title":"输出多个结果","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"不错的put","error":"","text":"<p>你意识到就算你输入了许多算式，却仅输出最后一个算式的结果吗？\n这是为什么？</p>\n\n<blockquote>\n<p>为了让这个网站易于使用，我已经通知Ruby让他把结果显示在输出框了。\n所以当你输入一个算式，你就可以得到一个结果。\n<strong>但只有最后一个算式有结果</strong>。并且仅在输出为空的情况下。</p>\n</blockquote>\n\n<p>所以当你打了两个或者以上的算式，Ruby只会显示最后一个算式的结果\n。</p>\n\n<p>你当然可以自己选择想要在屏幕上输出什么！只需要在每个算式前打上 <strong>puts</strong>。（记得要加空格）。puts的意思是：<em>打印某些东西在屏幕上</em>。</p>\n\n<p>试试这个:</p>\n\n<pre><code>puts 4 * 10\nputs 5 - 12\nputs 30 / 4\n</code></pre>\n\n<p>现在把最后一个算式前的puts去掉，看看会发生什么。</p>\n","load_code":""},
"5":{"lang":"ZH","title":"说出你的名字","chapter":"N","answer":"[a-zA-Z]{1,1}","ok":"完美，你已经构造了一个由你的名字的字母组成的字符串","error":"","text":"<p>当然，电脑们在数学方面非常拿手。我们继续，想看看你的名字如何被逆置？</p>\n\n<p>第一步，把你的名字放进这样的引号里:</p>\n\n<pre><code>&quot;Jimmy&quot;\n</code></pre>\n","load_code":""},
"6":{"lang":"ZH","title":"倒着念你的名字","chapter":"N","answer":"\\w+","ok":"错不","error":"","text":"<p>字符串是指电脑可以处理的字符的组合。想象一下许多字符们被挂在晾衣线上，而这两个引号就像是衣夹。引号代表开端和结尾。</p>\n\n<p>用下面这行代码来逆置你的名字: </p>\n\n<pre><code>&quot;Jimmy&quot;.reverse\n</code></pre>\n\n<p>(别忘了打!)</p>\n","load_code":""},
"7":{"lang":"ZH","title":"数字母","chapter":"N","answer":"^\\d+$","ok":"是滴，.length也是一个‘方法’（method）","error":"","text":"<p>你已经对你的名字使用了逆置（.reverse）方法(method)！\n把你的名字放进引号，你就有了一个字符串。然后你调用了逆置方法，这可以让你的名字倒过来写。</p>\n\n<p>现在，让我们看看你的名字中有多少字母:</p>\n\n<pre><code>&quot;Jimmy&quot;.length\n</code></pre>\n","load_code":""},
"8":{"lang":"ZH","title":"重复中","chapter":"N","answer":"(\\w+)","ok":"很高兴认识你。很高兴认识你。很高兴认识你。","error":"","text":"<p>现在，你可能想知道这些东西有什么用。</p>\n\n<p>好吧，我相信你一定去过某些网站，它尖叫着说：<strong>嘿，你的密码太短了！</strong>。</p>\n\n<p>懂了吧，有程序使用了那个简单的 <strong>.length</strong> 代码。</p>\n\n<p>看好了。让我们把你的名字乘以5。</p>\n\n<pre><code>&quot;Jimmy&quot; * 5\n</code></pre>\n","load_code":""},
"9":{"lang":"ZH","title":"总结（第一部分）就到此为止!","chapter":"Y","answer":"NoMethodError|undefined","ok":"不不不，你不能逆置一个数字，点击‘Next’来继续","error":"","text":"<p>让我们看看你在第一分钟内学到了什么。</p>\n\n<h3>编辑器</h3>\n\n<p>在编辑器中输入代码，并点击运行，就会在输出窗口中得到一个答案。\n(几乎)所有的代码都会给出一个答案。</p>\n\n<h3>数字和字符串</h3>\n\n<p>数字和字符串是Ruby的数学和文本对象。</p>\n\n<h3>方法（Methods）</h3>\n\n<p>你已经使用了英文方法，如reverse和length。以及如乘法的符号方法。*<br>\n<strong>方法指的是执行的行为!</strong></p>\n\n<p>这是你学习的本质。把简单的东西，玩弄它们，并把它们组合\n新东西。是不是感到很舒服？保证你是的。</p>\n\n<h2>好吧。</h2>\n\n<p>让我们做一些不舒服的事情。试试颠倒一个数字。</p>\n\n<pre><code>40.reverse\n</code></pre>\n","load_code":""},
"10":{"lang":"ZH","title":"停下，你在狂吠!","chapter":"N","answer":"^\\d{1,}$","ok":"只有字符串才能被逆置！","error":"","text":"<p>你不可以逆置数字40，我猜你可以抱着你的显示器并把它对着镜子，但逆置一个数字听起来就不合理。</p>\n\n<p>Ruby报错了。Ruby在告诉你并不存在逆置数字的方法。</p>\n\n<p>但如果先把数字转换成字符呢:</p>\n\n<pre><code>40.to_s.reverse\n</code></pre>\n","load_code":""},
"11":{"lang":"ZH","title":"苹果和橘子是不一样的","chapter":"N","answer":"\\[\\]","ok":"很棒，这是一个空列表","error":"","text":"<p>并且数字与字符串是不同的.</p>\n\n<p>虽然你可以对Ruby中的任何对象使用方法，但某些方法只对某些特定种类的东西有用。\n但你可以随意使用Ruby中的&quot;to&quot;方法来转换类型</p>\n\n<ul>\n<li><strong>to_s</strong> 将对象转换为 （to <strong>s</strong>trings）           字符串</li>\n<li><strong>to_i</strong> 将对象转换为 （to <strong>i</strong>ntegers (numbers)）整数</li>\n<li><strong>to_a</strong> 将对象转换为 （to <strong>a</strong>rrays）            数组</li>\n</ul>\n\n<p><strong>数组又是什么？!</strong></p>\n\n<p>他们是列表。 输入一组括号:</p>\n\n<pre><code>[]\n</code></pre>\n","load_code":""},
"12":{"lang":"ZH","title":"排好队","chapter":"N","answer":"^\\[([-\\.\\d]+)(\\s*,\\s*[-\\d\\.]+){3,}\\]$","ok":"超级棒","error":"尝试加入第四个数","text":"<p>列表（数组）以 <strong>特定的顺序</strong> 储存对象。</p>\n\n<p>就像在排队买爆米花，你不会想着把你前面的人推开，但你却关注着你后面的人，对吧？\n一个现成的列表，彩票数字: </p>\n\n<pre><code>[12, 47, 35]\n</code></pre>\n\n<p>尝试在列表中增加一个数字：在35后面打一个逗号，然后输入一个数字，空格是选择性的，可加可不加。</p>\n","load_code":""},
"13":{"lang":"ZH","title":"有一个举手了","chapter":"N","answer":"^47$","ok":"可以","error":"","text":"<p>由彩票数字组成的列表里，哪一个数最大?</p>\n\n<p>试试这个: </p>\n\n<pre><code>[12, 47, 35].max\n</code></pre>\n","load_code":""},
"14":{"lang":"ZH","title":"把清单保存起来","chapter":"N","answer":"^\\[(\\d+)(,\\s*\\d+){2,}\\]$","ok":"保存成功!","error":"","text":"<p>不错，不错。但你并不想在每次你需要用到它的时候都重新打一遍，对吧？</p>\n\n<p>让我们把数字保存在一个名为彩票（ticket）的的变量里: </p>\n\n<pre><code>ticket = [12, 47, 35]\n</code></pre>\n","load_code":""},
"15":{"lang":"ZH","title":"现在输入ticket","chapter":"N","answer":"\\[(\\d+(, )?){2,}\\]","ok":"还是原来的状态!","error":"","text":"<p>现在，输入:</p>\n\n<pre><code>ticket\n</code></pre>\n","load_code":"ticket = [12, 47, 35]"},
"16":{"lang":"ZH","title":"保存了，又藏起来了","chapter":"N","answer":"\\[12, 35, 47\\]","ok":"你已经对列表进行了排序","error":"","text":"<p>把抽签号码记下来，把它装进了名为ticket的变量中。\n这里，变量的名字也可以是其他的，比如 <strong>jimmyslist</strong>。</p>\n\n<p>你会发现，编程主要与变量有关。</p>\n\n<p>让我们把你的彩票号码排序一下，怎么样?</p>\n\n<p>试用一下代码: </p>\n\n<pre><code>ticket.sort!\n</code></pre>\n\n<p>你创建了一个列表。并将它排序了。变量ticket已经改变了。\n你有没有注意到 <strong>sort!</strong> 方法在结尾有一个又大又粗的感叹号?\n很多时候，如果Ruby方法永久性地改变了变量，就会发出这样的声音。\n没什么特别的，只是个标记。</p>\n","load_code":"ticket = [12, 47, 35]"},
"17":{"lang":"ZH","title":"元素","chapter":"N","answer":"^(12|35|47)$","ok":"完成","error":"差一点","text":"<p>我们已经把在变量ticket里的彩票数字排序了，那怎么再把它们拿出来呢？</p>\n\n<p>我们已经知道了可以用 <strong>max</strong> 来得到最大的值。\n同样的，你可以\n用 <strong>first</strong> 或者 <strong>last</strong> 来得到第一个或是第二个元素。\n可如果你想要一个特定的值呢？</p>\n\n<h3>[ ]</h3>\n\n<p>Ruby使用方括号[ ]来选择元素\n方括号在Ruby中非常常见\n它们就像用来瞄准目标的瞄准器\n意味着“<strong>我要去寻找</strong>”，准备，瞄准。</p>\n\n<p>让我们输出我们全部的彩票数字</p>\n\n<pre><code>puts ticket[0]\nputs ticket[1]\nputs ticket[2]\n</code></pre>\n\n<p>我们为什么使用 [0], [1], [2]?</p>\n\n<p>而不是 [1], [2] 和 [3]? 难道这是来自日本的神秘佛教计数法吗？不, 我们computer people就是喜欢从0开始数。不仅仅是Ruby，大多数编程语言都从0开始数。</p>\n\n<blockquote>\n<p>一个小提示: 你可以按 <strong>Copy</strong> 按钮，把示例代码复制到编辑器中。</p>\n</blockquote>\n","load_code":"ticket = [12, 47, 35]"},
"18":{"lang":"ZH","title":"总结#2 来了","chapter":"Y","answer":"\\w+","ok":"押韵吗?","error":"","text":"<p>现在，回顾一下你的第二分钟学了什么:</p>\n\n<h3>Errors（错误）</h3>\n\n<p>如果你尝试逆置一个数字，Ruby就会告诉你这个。</p>\n\n<h3>数组</h3>\n\n<p>数组是以某种顺序来储存元素的列表。\n我们也学了如何创造数组，与如何从中获取元素。</p>\n\n<h3>变量</h3>\n\n<p>变量保存事物，并赋予其名称。要想在变量中存储一些东西，这样:\nticket = [14, 37, 18].</p>\n\n<h3>2/8</h3>\n\n<p>总共有八个部分。你已经走了八分之二了!这很简单，\n你不觉得吗?后面还有更好玩的东西。</p>\n\n<p>让我们改变一下方向。我在某个变量里给你塞了首诗。\n看一看。输入:</p>\n\n<pre><code>puts poem\n</code></pre>\n","load_code":"poem = \"My toast has flown from my hand\\nAnd my toast has gone to the moon.\\nBut when I saw it on television,\\nPlanting our flag on Halley's comet,\\nMore still did I want to eat it.\\n\""},
"19":{"lang":"ZH","title":"真是悲哀啊，最讨厌有吐司的诗了","chapter":"N","answer":"(toast){0}","ok":"棒极了","error":"还有吐司的味道。","text":"<p>看，这诗不错。你不需要喜欢它。\n随便修改，可以把toast改成各种瓜。\n试试下面这个，然后检查一下新的诗：</p>\n\n<pre><code>poem.gsub(&quot;toast&quot;, &quot;honeydew&quot;)\n</code></pre>\n\n<p><strong>gsub</strong> 方法是global substitute的缩写。\n它会将所有&quot;toast&quot;替换为&quot;honeydew&quot;。</p>\n","load_code":"prev"},
"20":{"lang":"ZH","title":"摆好姿势，瞄准","chapter":"N","answer":"^\\n.ti tae ot (.+)","ok":"好的,当然。所以整首诗被倒着写了。","error":"","text":"<p>有一个问题:当我们逆置整首诗会发生什么？</p>\n\n<pre><code>poem.reverse\n</code></pre>\n","load_code":"prev"},
"21":{"lang":"ZH","title":"太多逆置了","chapter":"N","answer":"^\\[\"More still did (.+)","ok":"差不多是我们想要的了","error":"","text":"<p>所以整首诗按照字母的顺序，被逐一倒置了。这显然不是我想要的。我期望按照行的顺序进行倒置，比如第一行变成最后一行。那么如下操作：</p>\n\n<pre><code>poem.lines.reverse\n</code></pre>\n\n<p>把最后一行移到第一行，把第一行移到最后一行。</p>\n","load_code":"prev"},
"22":{"lang":"ZH","title":"链式方法的小环","chapter":"N","answer":"^More still did (.+)","ok":"好样的，我的朋友！<br/>join方法把那个数组的行数放在一起，变成一个字符串。","error":"","text":"<p>那么你看到了什么？那里发生了什么？你输入了 <strong>poem.lines.reverse</strong>，发生了什么？</p>\n\n<p>发生了两件事。你用lines把诗变成了一个列表。\nLines 决定了字符串被分割的方式，并将其转换为一个数组。</p>\n\n<p>然后，你反转了这个列表。每一行都是。你反转了它们。就这样了。</p>\n\n<p>让我们再把一个方法放在最后：</p>\n\n<pre><code>puts poem.lines.reverse.join\n</code></pre>\n\n<p>像这样的方法组合被称为<em>方法链</em>。</p>\n","load_code":"prev"},
"23":{"lang":"ZH","title":"这里是总结(三)","chapter":"Y","answer":"\\{\\}","ok":"创建了空hash!","error":"","text":"<h3>感叹号</h3>\n\n<p>方法的名称中可能有感叹号(也有问号)。\n这些只是为了更好地解释它们的功能。没什么大不了的。</p>\n\n<h3>字符串操作</h3>\n\n<p>搜索和更改字符串</p>\n\n<h3>链接</h3>\n\n<p>链接方法可以让您完成更多的工作。将一首诗分解，倒写，重新组合:\n<strong>poem.lines.reverse.join</strong></p>\n\n<p>你还想再弄点诗吗?\nstring的所有方法列表在<a href=\"http://ruby-doc.org/core/classes/String.html\" target=\"_blank\">这里</a>.</p>\n\n<p>试试看这些吧: poem.downcase or poem.swapcase</p>\n\n<h2>准备好了?</h2>\n\n<p>准备好继续的话，输入:</p>\n\n<pre><code>books = {}\n</code></pre>\n","load_code":"prev"},
"24":{"lang":"ZH","title":"一本空白的小书","chapter":"N","answer":"^(splendid|quite_good|mediocre|quite_not_good|abysmal)$","ok":"是的，这是一个新的评论","error":"splendid, quite_good, mediocre, quite_not_good, abysmal.<br/>请使用其中之一。另外，不要忘记冒号。","text":"<p>现在制作的是空的 <strong>哈希（hash）</strong>。哈希就像数组一样，不同之处在于每个元素都有自己的名字。</p>\n\n<p>我们要在新的哈希中塞进一些简易的书评，\n评价体系如下。</p>\n\n<ul>\n<li>:splendid &rarr; 大师之作</li>\n<li>:quite_good &rarr; 很享受，啊对</li>\n<li>:mediocre &rarr; 半好半坏</li>\n<li>:quite_not_good &rarr; 特别差</li>\n<li>:abysmal &rarr; 热气腾腾的残骸</li>\n</ul>\n\n<p>要给一本书评分，把书名放在方括号里，把评分放在等号后面。比如说：</p>\n\n<pre><code>books[&quot;Gravitys Rainbow&quot;] = :splendid\n</code></pre>\n\n<blockquote>\n<p>现在我想应该告诉你，TryRuby的所有课程都是相互独立的。\n所以，如果你在这里疯狂地输入书评，你只能在这一课中使用它们。 \n如果你想在下一课使用你的评论，你应该复制/粘贴它们。 \n不要太担心这个，每一课都有很多预定义的东西供你玩耍。</p>\n</blockquote>\n","load_code":"books = {}"},
"25":{"lang":"ZH","title":"更多的评论","chapter":"N","answer":"[3-9]","ok":"看到了吧，length方法不仅可以用于字符串，还可以用于数组和哈希。","error":"","text":"<p>继续增加书评吧。\n要查看完整的列表，输入 <strong>puts books</strong>。</p>\n\n<p>再重复一遍，评价体系是:splendid、:quite<em>good、:mediocre、:quite</em>not\\ _good、:abysmal。</p>\n\n<p>这些评价不是一串文字。在单词前面加冒号的话，那个就变成了 <strong>符号</strong>。\n从计算机存储器的角度来看，符号比字符串成本更低。\n如果你在程序中不断重复使用相同的单词，你就应该使用符号。\n不是在内存上有那个单词的数千个副本，而是计算机只存储符号 <strong>一次</strong>。</p>\n\n<p>更重要的是，用符号来表示它会告诉电脑这不仅仅是一个单词，而是在程序中有意义的。</p>\n\n<p>如果输入了两个以上的书评，请使用 <strong>books.length</strong> 确认哈希中有哪些书评：</p>\n\n<pre><code>books[&quot;The deep end&quot;]  = :abysmal\nbooks[&quot;Living colors&quot;] = :mediocre\n\nputs books\n\nputs books.length\n</code></pre>\n","load_code":"books = {\"Gravitys Rainbow\" => :splendid}"},
"26":{"lang":"ZH","title":"等等，我喜欢Gravity's Rainbow吗?","chapter":"N","answer":"^(splendid|quite_good|mediocre|quite_not_good|abysmal)$","ok":"我超级喜欢","error":"","text":"<p>Ruby的优点之一是名字经常被重复使用。\n多亏了这个，必须要记住的名字变少了。</p>\n\n<p>还记得从数组中提取元素的时候，像 <strong>puts ticket[1]</strong> 那样需要使用数值吗?</p>\n\n<p>哈希也可以用同样的方法提取元素。但是，使用名字而不是数值。</p>\n\n<p>假设你想检查旧的书评。在括号里输入书名。但把等号去了。\n如下所示：</p>\n\n<pre><code>puts books[&quot;Gravitys Rainbow&quot;]\n</code></pre>\n","load_code":"books = {\"Gravitys Rainbow\" => :splendid, \"The deep end\" => :abysmal, \"Living colors\" => :mediocre}"},
"27":{"lang":"ZH","title":"哈希是成对的","chapter":"N","answer":"^\\[\".*\"\\]","ok":"你找到键（keys）了","error":"","text":"<p>记住哈希并不会把储存的东西排好序，那不是它的工作，它只会把东西配对。\n两个东西：<strong>键</strong> 与 <strong>值</strong></p>\n\n<p>在你的评论中，书名是键，书评是值</p>\n\n<p>如果你想看你评论过的书的题目:</p>\n\n<pre><code>books.keys\n</code></pre>\n\n<p>你可以方法换成.values</p>\n","load_code":"prev"},
"28":{"lang":"ZH","title":"你标准很高?","chapter":"N","answer":"\"mediocre\"","ok":"不错，你已经为你的书评做了一个评分卡了","error":"","text":"<p>你写了刻薄或不公平的书评吗?\n那么，让我们准备一个名为 <strong>ratings</strong> 的新的哈希来打分吧。</p>\n\n<p>怎么做呢?对啊，就是不断地增加书评。请输入以下内容:</p>\n\n<pre><code>ratings = Hash.new {0}\n\nbooks.values.each { |rate|\n  ratings[rate] += 1\n}\n\nputs ratings\n</code></pre>\n\n<p>代码中的直线是管道字符，位于键盘中Enter键的正上方</p>\n\n<p><em>+= 1</em>表示:值增加1。</p>\n\n<p>如果你不明白这里发生的一切，也不要担心。这将在稍后揭晓。</p>\n","load_code":"books = {\"Gravitys Rainbow\" => :splendid, \"The deep end\" => :abysmal, \"Living colors\" => :mediocre, \"Bumblebees\" => :mediocre}"},
"29":{"lang":"ZH","title":"一个统计","chapter":"N","answer":"\\w+","ok":"Yodelay!","error":"","text":"<p>我们刚刚使用的一个美妙的新东西是 <strong>块（block）</strong>。我们将进一步探讨这些问题\n在这一课和下一课。但是，基本上，块是由花括号包围的一小段Ruby代码\n括号。</p>\n\n<p>试一试另一个块:</p>\n\n<pre><code>5.times { print &quot;Odelay! &quot; }\n</code></pre>\n\n<p>块总是附加到方法上。比如 <strong>times</strong> 方法，这个块将\n一遍又一遍地运行代码。(在这个例子中，它将运行五次。)</p>\n","load_code":""},
"30":{"lang":"ZH","title":"你有时间吗?","chapter":"N","answer":"^[0-9]$","ok":"次数对了","error":"让这些块运行0次到9次","text":"<p>从第一个运用块的例子我们可以看到（在数评分时），我们可以给块传值。传什么值由控制块的方法来决定。</p>\n\n<p>块中 <strong>收到（received）</strong> 的值被放在块开头的在两个管道符号之间的变量名中: |</p>\n\n<p>Let&rsquo;s try that with this block:</p>\n\n<pre><code>5.times { |time|\n  puts time\n}\n</code></pre>\n\n<p>这里，方法 <strong>.times</strong> 给变量 <strong>|time|</strong> 传了一个值。但是注意这个变量仅在块中有效。</p>\n\n<blockquote>\n<p>你可以尝试把代码分成几段，可以有助于你理解。</p>\n</blockquote>\n","load_code":""},
"31":{"lang":"ZH","title":"现在到了总结#4","chapter":"Y","answer":"","ok":"","error":"","text":"<p>这最后一课稍微长一点。你可能已经用了三分钟的时间来学习:</p>\n\n<h3>哈希</h3>\n\n<p>带有卷页的小字典:<strong>{}</strong></p>\n\n<h3>符号</h3>\n\n<p>带有冒号的微小、高效的代码，比如:<strong>:splendid</strong></p>\n\n<h3>块</h3>\n\n<p>可以添加到许多Ruby方法中的代码块。这是你用过的代码\n建立一个记分卡:\n<strong>books.values.each { |rate| ratings[rate] += 1 }</strong></p>\n\n<h3>下一节</h3>\n\n<p>下一课我们将更深入地探讨方法。</p>\n","load_code":""},
"32":{"lang":"ZH","title":"To (be) or not to (be)","chapter":"N","answer":"","ok":"","error":"","text":"<p>一个还没有认真探讨的东西：方法参数\n还记得我们怎么修改那首诗的吗：\n<strong>poem.gsub(&ldquo;toast&rdquo;, &ldquo;honeydew&rdquo;)</strong></p>\n\n<p>gsub方法需要两个参数，这两个参数即为括号中的那两个字符串。</p>\n\n<h3>括号</h3>\n\n<p>实际上，Ruby不是很在意你去掉括号，这样也可以运行:\n<strong>poem.gsub &ldquo;toast&rdquo;, &ldquo;honeydew&rdquo;</strong></p>\n\n<p>实际上我们已经用了好多次一个带着括号的方法，很显然:</p>\n\n<pre><code>puts &quot;Hello&quot;\nputs(&quot;Hello&quot;)\n</code></pre>\n\n<p>是的 <strong>puts</strong> 是的 <strong>puts</strong> 是一个方法，加不加括号对Ruby来说一样，但是\n不加括号使代码更易读，并且节省时间</p>\n\n<blockquote>\n<p>所以我想结论是，你可以用括号做任何你喜欢的事，只要你\n代码读起来很好。</p>\n</blockquote>\n\n<h3>to (be) or not to (be)</h3>\n\n<p>所以如果 <em>to</em> 是一个方法 <em>be</em> 是一个参数，我们现在知道这个古老问题的答案了\n这只是单纯的个人喜好问题<em>to be</em> or <em>to(be)</em>.</p>\n\n<p>还想要更多的莎士比亚作品吗，继续读。</p>\n","load_code":"poem = \"My toast has flown from my hand\\nAnd my toast has gone to the moon.\\nYada yada yada\\n\""},
"33":{"lang":"ZH","title":"驯悍记","chapter":"N","answer":"^tame","ok":"不错不错","error":"","text":"<p>你现在完全知道如何使用Ruby。我的意思是你已经掌握了基本的东西。\n你只需要继续学习更多的方法和尝试更复杂的块。</p>\n\n<p>但是Ruby还有一个方面我们还没有解决。制作你自己的方法。\n<strong>Ahem!</strong> 让我们把它完成吧。</p>\n\n<p>除了使用Ruby的内置方法（如puts, sort, times），你还可以定义\n你可以定义你自己的方法。为什么这是个好主意？有两个原因。</p>\n\n<h3>让你的程序更短</h3>\n\n<p>如果你必须在你的代码的多个部分做同样的事情，那么把这些代码放在一个单独的方法中会比较容易。\n把这些代码放在一个单独的方法中。你的代码会更短。</p>\n\n<h3>为了使你的代码更容易阅读</h3>\n\n<p>假设你的程序需要做很多不同的事情。\n你可以把所有的代码塞进一个长的部分。但这将是非常困难的\n阅读和理解这些代码。</p>\n\n<p>相反，你应该把你的代码切割成不同的方法，并给每个方法一个容易理解的\n的英文名称。你以后会感谢自己的。</p>\n\n<p>那么，我们如何定义一个方法呢？就像这样。</p>\n\n<pre><code>def tame( number_of_shrews )\nend\n</code></pre>\n","load_code":""},
"34":{"lang":"ZH","title":"在Ruby中，Def Leppard 的意思是: 定义Leppard方法","chapter":"N","answer":"^tame","ok":"Tame is not lame","error":"","text":"<p>嘿，好吧，你做到了。你正在创建你自己的方法。你以def开头，后面是方法的名称。\n还有一个方法需要的参数列表。这并不可怕，也不危险。\n我们所要做的就是用Ruby来写满它，然后用end来结束它。</p>\n\n<p>下面是代码：</p>\n\n<pre><code>def tame( number_of_shrews )\n  number_of_shrews.times {\n    puts &quot;Tamed a shrew&quot;\n  }\nend\n</code></pre>\n\n<blockquote>\n<p><strong>P.S.</strong><br>\n如果你不懂这一章的标题\n<a href=\"http://en.wikipedia.org/wiki/Def_Leppard\" target=\"_blank\">Def Leppard</a>\n是一个，曾经很有名的，英语摇滚乐队的名字</p>\n</blockquote>\n","load_code":""},
"35":{"lang":"ZH","title":"自己创造的成熟的果实","chapter":"N","answer":"^Tamed a shrew","ok":"这将让那些泼妇看到","error":"","text":"<p>一个新的方法诞生了，让我们马上调用一下：</p>\n\n<pre><code>tame 5\n</code></pre>\n","load_code":"def tame(number_of_shrews);number_of_shrews.times{puts \"Tamed a shrew\"};end;"},
"36":{"lang":"ZH","title":"奉献与索取","chapter":"N","answer":"\\d+","ok":"不错。好样的。","error":"","text":"<p>大多数方法不仅需要一些参数作为输入，而且也会 <strong>返回</strong> 一些东西。\n我对我们的方法做了一些改变，所以它将返回一个值给你。试试吧：</p>\n\n<pre><code>def tame( number_of_shrews )\n  number_of_shrews.times {\n    puts &quot;Tamed a shrew&quot;\n  }\n  return number_of_shrews\nend\n\nputs tame(3)\n</code></pre>\n\n<h3>返回</h3>\n\n<p>那么，既然你在这里变得如此高阶和能干，给你提示。\n你可以在方法的最后一行省略 <strong>return</strong> 这个词。\nRuby将自动返回方法中最后使用的值。</p>\n\n<p>所以我们修改最后一行为: <strong>number_of_shrews</strong>.</p>\n\n<p>但是既然方法 <strong>.times</strong> 也返回 <em>number_of_shrews</em> 我么可以省去最后一整行，所以我们最初的方法已经做到了我们一直想做的事情。</p>\n","load_code":""},
"37":{"lang":"ZH","title":"你好，谁在那里？总结#5挥舞着它的帽子!","chapter":"Y","answer":"","ok":"","error":"","text":"<p>做得好，做得好，做得好，做得好!</p>\n\n<p>真的，真的，真的，真的，真真真真真真真的！</p>\n\n<p>这里是你生命中上几分钟的回顾。</p>\n\n<h3>方法</h3>\n\n<p>方法可以用 <strong>def</strong> 来定义，并且有一个名字。方法使你的程序更短,\n而且更容易阅读。</p>\n\n<h3>参数</h3>\n\n<p>方法可以有参数。</p>\n\n<h3>返回值</h3>\n\n<p>方法（几乎）总是返回一个值。</p>\n\n<h2>现在</h2>\n\n<p>To (be) or not to (be) 不再是一个问题了。准备好看更多的莎士比亚了吗？</p>\n","load_code":""},
"38":{"lang":"ZH","title":"世界是我们的囊中之物","chapter":"N","answer":"^\\{\\\"William","ok":"很好。有点难读。","error":"","text":"<p>目前我们只运行了我们输入的程序，这很棒，展示出来的信息是史诗级的，但如今是互联网纪元，\n所以是时候把全世界囊括进我们的程序中了。</p>\n\n<p>许多，许多，许多网站你可以用来获取信息，比如这个获取关于Ruby的<a href=\"http://news.google.com/news/section?q=ruby&output=rss\" target=\"_blank\">Google新闻资讯</a></p>\n\n<p>你的网络浏览器可能会很好地为你显示它。如果你看一下源代码\n(键入：Control-U），你会看到一长串格式奇怪的文本。以谷歌为例,\n它是以<strong>rss</strong>格式显示的。</p>\n\n<h3>格式</h3>\n\n<p>还有许多其他格式，名字很奇怪，在网络上可以使用，比如。\nhtml、xml和json。是的，甚至这个网站也使用其中的一些格式。</p>\n\n<p>我为你准备了一个方法，可以从互联网上获取威廉-莎士比亚的全部作品的清单。\n(别担心，它实际上来自本网站运行的同一服务器，所以,\n我们没有打扰到任何人。)</p>\n\n<p>获取数据:</p>\n\n<pre><code>get_shakey\n</code></pre>\n","load_code":"def get_shakey;JSON.parse(\"{\\\"William Shakespeare\\\": {\\\"1\\\": {\\\"title\\\": \\\"The Two Gentlemen of Verona\\\", \\\"finished\\\": 1591},\\\"2\\\": {\\\"title\\\": \\\"The Taming of the Shrew\\\", \\\"finished\\\": 1591},\\\"3\\\": {\\\"title\\\": \\\"Henry VI, Part 2\\\", \\\"finished\\\": 1591},\\\"4\\\": {\\\"title\\\": \\\"Henry VI, Part 3\\\", \\\"finished\\\": 1591},\\\"5\\\": {\\\"title\\\": \\\"Henry VI, Part 1\\\", \\\"finished\\\": 1592},\\\"6\\\": {\\\"title\\\": \\\"Titus Andronicus\\\", \\\"finished\\\": 1592},\\\"7\\\": {\\\"title\\\": \\\"Richard III\\\", \\\"finished\\\": 1593},\\\"8\\\": {\\\"title\\\": \\\"Edward III\\\", \\\"finished\\\": 1593},\\\"9\\\": {\\\"title\\\": \\\"The Comedy of Errors\\\", \\\"finished\\\": 1594},\\\"10\\\": {\\\"title\\\": \\\"Love's Labour's Lost\\\", \\\"finished\\\": 1595},\\\"11\\\": {\\\"title\\\": \\\"Love's Labour's Won\\\", \\\"finished\\\": 1596},\\\"12\\\": {\\\"title\\\": \\\"Richard II\\\", \\\"finished\\\": 1595},\\\"13\\\": {\\\"title\\\": \\\"Romeo and Juliet\\\", \\\"finished\\\": 1595},\\\"14\\\": {\\\"title\\\": \\\"A Midsummer Night's Dream\\\", \\\"finished\\\": 1595},\\\"15\\\": {\\\"title\\\": \\\"King John\\\", \\\"finished\\\": 1596},\\\"16\\\": {\\\"title\\\": \\\"The Merchant of Venice\\\", \\\"finished\\\": 1597},\\\"17\\\": {\\\"title\\\": \\\"Henry IV, Part 1\\\", \\\"finished\\\": 1597},\\\"18\\\": {\\\"title\\\": \\\"The Merry Wives of Windsor\\\", \\\"finished\\\": 1597},\\\"19\\\": {\\\"title\\\": \\\"Henry IV, Part 2\\\", \\\"finished\\\": 1598},\\\"20\\\": {\\\"title\\\": \\\"Much Ado About Nothing\\\", \\\"finished\\\": 1599},\\\"21\\\": {\\\"title\\\": \\\"Henry V\\\", \\\"finished\\\": 1599},\\\"22\\\": {\\\"title\\\": \\\"Julius Caesar\\\", \\\"finished\\\": 1599},\\\"23\\\": {\\\"title\\\": \\\"As You Like It\\\", \\\"finished\\\": 1600},\\\"24\\\": {\\\"title\\\": \\\"Hamlet\\\", \\\"finished\\\": 1601},\\\"25\\\": {\\\"title\\\": \\\"Twelfth Night\\\", \\\"finished\\\": 1601},\\\"26\\\": {\\\"title\\\": \\\"Troilus and Cressida\\\", \\\"finished\\\": 1602},\\\"27\\\": {\\\"title\\\": \\\"Sir Thomas More\\\", \\\"finished\\\": 1604},\\\"28\\\": {\\\"title\\\": \\\"Measure for Measure\\\", \\\"finished\\\": 1604},\\\"29\\\": {\\\"title\\\": \\\"Othello\\\", \\\"finished\\\": 1604},\\\"30\\\": {\\\"title\\\": \\\"All's Well That Ends Well\\\", \\\"finished\\\": 1605},\\\"31\\\": {\\\"title\\\": \\\"King Lear\\\", \\\"finished\\\": 1606},\\\"32\\\": {\\\"title\\\": \\\"Timon of Athens\\\", \\\"finished\\\": 1606},\\\"33\\\": {\\\"title\\\": \\\"Macbeth\\\", \\\"finished\\\": 1606},\\\"34\\\": {\\\"title\\\": \\\"Antony and Cleopatra\\\", \\\"finished\\\": 1606},\\\"35\\\": {\\\"title\\\": \\\"Pericles, Prince of Tyre\\\", \\\"finished\\\": 1608},\\\"36\\\": {\\\"title\\\": \\\"Coriolanus\\\", \\\"finished\\\": 1608},\\\"37\\\": {\\\"title\\\": \\\"The Winter's Tale\\\", \\\"finished\\\": 1611},\\\"38\\\": {\\\"title\\\": \\\"Cymbeline\\\", \\\"finished\\\": 1610},\\\"39\\\": {\\\"title\\\": \\\"The Tempest\\\", \\\"finished\\\": 1611},\\\"40\\\": {\\\"title\\\": \\\"Cardenio\\\", \\\"finished\\\": 1613},\\\"41\\\": {\\\"title\\\": \\\"Henry VIII\\\", \\\"finished\\\": 1613},\\\"42\\\": {\\\"title\\\": \\\"The Two Noble Kinsmen\\\", \\\"finished\\\": 1614}}}\");end;"},
"39":{"lang":"ZH","title":"两个高贵的亲戚","chapter":"N","answer":"^The Two Noble Kinsmen$","ok":"这看起来好多了","error":"","text":"<p>我们从网上搜集了一些剧本，剧本的清单储存在json格式中。\n幸运的是，Ruby提供了一个将json数据转化为Ruby哈希的方法。\n<em>get_shakey</em>方法能帮助我们。</p>\n\n<p>由于json的格式还是被保留在了哈希中，这还是有点难阅读的。\n让我们写一个能增加其可读性的方法。</p>\n\n<p>如果你仔细观察下面的代码，你会发现它们以一种嵌套结构排列。\n这种结构在互联网上可以经常见到</p>\n\n<ul>\n  <li>&ldquo;William Shakespeare&rdquo;\n  <ul>\n      <li>&ldquo;1&rdquo;\n      <ul>\n        <li>&ldquo;title&rdquo;: &ldquo;The Two Gentlemen of Verona&rdquo;</li>\n        <li>&ldquo;finished&rdquo;: 1591</li>\n      </ul>\n      </li>\n      <li>&ldquo;2&rdquo;\n      <ul>\n        <li>&ldquo;title&rdquo;: &ldquo;The Taming of the= Shrew&rdquo;</li>\n        <li>&ldquo;finished&rdquo;: 1591</li>\n      </ul>\n      </li>\n      <li>&hellip;</li>\n  </ul>\n  </li>\n</ul>\n\n<p>要想列出剧本的名字我们要先通过找到哈希顶部的元素，也就是&quot;William Shakespeare&quot;，然后对其下属的元素进行<strong>iterate(迭代)</strong> 搜索。\nRuby有一个用以迭代的方法。也就是<strong>each</strong>。我们在创建书评系统的时候曾用到过这个方法。</p>\n\n<p>所有由<strong>each</strong> 方法返回的值都传到了一个块中：</p>\n\n<pre><code>s = get_shakey\n\ns[&quot;William Shakespeare&quot;].each { |key, val|\n  puts val[&quot;title&quot;]\n}\n</code></pre>\n","load_code":"prev"},
"40":{"lang":"ZH","title":"全加在一起","chapter":"N","answer":"^4$","ok":"没错，莎士比亚在1591年写了四部剧","error":"1591年的答案应该是4部","text":"<p>假如我们想要知道莎士比亚在某一特定的年份写的剧的名字和数量。</p>\n\n<p>Ruby提供了<strong>select</strong> 方法来检索哈希中的值。它能根据我们在块中的定义来检索并返回值</p>\n\n<p>我们利用在 <strong>each</strong> 方法中链接 <strong>select</strong> 方法。这种方法链接，我们已经在之前逆置诗的时候用过了。</p>\n\n<p>我已经替你定义好了 <strong>count_plays</strong> 你试着通过下面的代码来找出莎士比亚在1591年写了多少剧本吧：</p>\n\n<pre><code>def count_plays(year)\n  s = get_shakey\n\n  s[&quot;William Shakespeare&quot;]\n    .select { |k, v|\n      v[&quot;finished&quot;] == year\n    }.each { |key, val|\n      puts val[&quot;title&quot;]\n    }.count\nend\n\nputs count_plays(0)\n</code></pre>\n\n<p>你注意到我在each方法的结尾链接了count方法吗。这将给我们一个 <strong>count_plays</strong> 方法的返回值。 </p>\n\n<p>有另一种写法，可以直接把 <strong>[&ldquo;William Shakespeare&rdquo;].select { |k, v|</strong> 写在 <strong>s = getshakey</strong> 后面。（不需要加.）</p>\n","load_code":"prev"},
"41":{"lang":"ZH","title":"一切都是美好的结局","chapter":"N","answer":"All's Well That Ends Well","ok":"True","error":"把1605作为第二个参数","text":"<p>好了，我们从互联网上得到了一些数据，我们选择了我们想要的东西并把它打印出来。\n还有什么需要改进的呢？我们可以把结果打印得更漂亮一点。比如添加年份,\n并将剧名和年份对齐。</p>\n\n<p>这意味着在一行中打印多个值。Ruby有一个很好的方法来实现。\n就如同打印一个字符串一样，如: <strong>puts &ldquo;Hi, my name is Jimmy&rdquo;</strong>。\n但我们要把Jimmy换成一个变量\n所以我们可以这样写:\n    <strong>&ldquo;Hi, my name is #{name}&rdquo;</strong>。</p>\n\n<p>第一步，把 <strong>Jimmy</strong> 用 <strong>#{}</strong> 代替。Ruby会为这个括号寻找所放进去的变量\n让我们修改一下我们的代码：</p>\n\n<pre><code>def print_plays(year_from, year_to)\n  get_shakey[&quot;William Shakespeare&quot;]\n    .select { |k, v|\n      year_from &lt;= v[&quot;finished&quot;] &amp;&amp;\n      year_to   &gt;= v[&quot;finished&quot;]\n    }.each { |k, v|\n      puts &quot;#{v[&quot;title&quot;].ljust(30)} #{v[&quot;finished&quot;]}&quot;\n    }\nend\nprint_plays(1600, 1605)\n</code></pre>\n\n<p>这个方法 <strong>.ljust(30)</strong> 的作用是，将打印出来的内容 <em>左对齐(left justified)</em> 给剧名占用30个字符大小，这样年份就会漂亮的对齐了。 </p>\n\n<p>试试看你能不能修改一下代码，把内容以这样的形式打印出来：<strong>1600 -&gt; As You Like It</strong>\n<strong>一切都是美好的结局?</strong> 嘿，我们还没学完了，不过也快了！</p>\n","load_code":"prev"},
"42":{"lang":"ZH","title":"要是我知道怎么做决定就好了","chapter":"N","answer":"","ok":"","error":"","text":"<p>在现实生活中，做决定是一个难题。但在Ruby中，\n就超级简单了。</p>\n\n<pre><code>if 1 &lt; 2\n  puts &quot;It is true: 1 is less than 2&quot;\nend\n</code></pre>\n\n<p>关键的是 <strong>if</strong>。 If 可以被添加在方法前或后，像这样:</p>\n\n<pre><code>puts &quot;It is true: 1 is less than 2&quot; if 1 &lt; 2\n</code></pre>\n\n<p><strong>If</strong> 方法需要一个参数。这个参数可以是任何你想要验证真假的表达式。\n 验证的结果只有 <strong>true（真）</strong> 或 <strong>false（假）</strong>.\n下面是一些表达式和他们的真假:</p>\n\n<pre><code>5     &lt;= 10     # =&gt; true\n&#39;abc&#39; == &#39;def&#39;  # =&gt; false\ntrue            # =&gt; true\n123456          # =&gt; true\n0               # =&gt; true\nnil             # =&gt; false\n&#39;xyz&#39;.empty?    # =&gt; false\n&#39;a&#39; &gt; 5         # =&gt; error:\n                # 字符串与\n                # 数字的比较会失败\n</code></pre>\n\n<p><em>if expression</em> 可以验证许多表达式。 \n它可以比较数字(1 &lt; 2)，变量(a &lt; 1)，和某一方法的返回值(&lsquo;xyz&rsquo;.empty?)。</p>\n","load_code":""},
"43":{"lang":"ZH","title":"我们有一个惊人的结论","chapter":"N","answer":"is not equal to 100$","ok":"这样好多了","error":"这肯定不对","text":"<p>看到这里面的两个等号了吗 <strong>&lsquo;abc&rsquo; == &lsquo;def&rsquo;</strong>?</p>\n\n<p><strong>==</strong> 意为 <strong>相等</strong>.\n我们之前见到的一个等号意为 <strong>将值赋值于一个变量</strong>.</p>\n\n<p>让这一切变的更令人迷惑：你可以在if方法后面写一个赋值语句：</p>\n\n<pre><code>a = 0\n\nif a = 100\n  puts &quot;Expression is true, but a is now: #{a}&quot;\nelse\n  puts &quot;#{a} is not equal to 100&quot;\nend\n</code></pre>\n\n<p>把=换成==，看看会发生什么</p>\n\n<p>我保证你有时会忘了打第二个等号。因为我也老是忘记。</p>\n\n<h3>else</h3>\n\n<p>在上面的代码中我加入了else表达式，这一部分代码会在\n<strong>if test-expression</strong> 判定为假的时候执行</p>\n\n<blockquote>\n<p>if-then-else有很多变种，详情请见：\n<a href=\"http://www.ruby-doc.org/core/doc/syntax/control_expressions_rdoc.html\" target=\"_blank\">here</a>.</p>\n</blockquote>\n","load_code":""},
"44":{"lang":"ZH","title":"我 饿","chapter":"N","answer":"^Me not hungry","ok":"对","error":"我不可能在上午10点饿","text":"<p>你已经有了很大进步。这对你来说是很简单的事情，但你记得吗，你在15分钟前还不知道什么是Ruby!\n你还不知道 <strong>有关Ruby的任何东西</strong>！</p>\n\n<p>最后一步。让我们把这一切联系起来，你懂的？让我们让它像一组非常漂亮的风铃一样响起来\n在神奇的阳光下，在海滩上的闪闪发光的风铃！</p>\n\n<p>我们先定义两种方法，然后再做出决定。</p>\n\n<pre><code>def hungry?(time_of_day_in_hours)\n  puts &quot;Me hungry&quot;\n  true\nend\n\ndef eat_an(what)\n  puts &quot;Me eat #{what}\\n&quot;\nend\n\neat_an &#39;apple&#39; if hungry?(14)\n\neat_an &#39;apple&#39; if hungry?(10)\n</code></pre>\n\n<p>试试看你能不能用 <strong>hungry?</strong> 方法来得出 <strong>&ldquo;Me not hungry&rdquo;</strong>，并且在时间小于12时使其返回假。</p>\n","load_code":""},
"45":{"lang":"ZH","title":"总结 #6 意味着你已经走了很远","chapter":"Y","answer":"\\{\\}","ok":"很好，这是一个空哈希","error":"","text":"<p>你是一个六级Ruby传教士了。我的意思是你做的很好，让我们来回顾一下：</p>\n\n<h3>数据</h3>\n\n<p>你从互联网上下载了一些数据，从这些数据中，你检索到了你想要的值。</p>\n\n<h3>迭代</h3>\n\n<p>你通过迭代一个哈希中的所有元素并且链接了一些方法。</p>\n\n<h3>漂亮的打印方式</h3>\n\n<p>如果这还不够，你利用格式化打印了一些值，使人们能够轻易读懂。实际上 <strong>你已经写出了一个真正的程序！</strong></p>\n\n<h3>IF</h3>\n\n<p>你已经学会了怎么用用 <strong>if</strong> 和 <strong>else</strong> 来操控你的程序。</p>\n\n<h2>那么</h2>\n\n<p>接下来会是什么? 你现在应该学些什么呢?\n哈，精彩的部分来了，我们要接着学了。学完剩下的两节课，就结束了。</p>\n\n<p>早前，我们想这样创建了哈希：</p>\n\n<pre><code>Hash.new\n</code></pre>\n","load_code":""},
"46":{"lang":"ZH","title":"不是学校班级，是工人阶级","chapter":"N","answer":"","ok":"","error":"","text":"<p>你看，大括号{}是Hash.new的一个快捷方式。new方法是用来给特定的类（class）制造对象（object）的。\n把类（class）理解成工人阶级（working class）中的阶级（class）&amp;mdash一组特定的对象，们是相似的，有相同的工作，穿着相同的衬衫。 \n类有什么用呢？</p>\n\n<h3>Blurbalizer<sup>TM</sup></h3>\n\n<p>你想出了一个新app的绝妙的点子，将会是下一代即时通信平台。\n你想要一个人们能够互相发送短信息的平台。\n你把这个平台上的信息称为Blurbs<sup>TM</sup>，一个Blurb<sup>TM</sup>的最大长度为40个字符。我们得再加一个发送似的情绪。</p>\n\n<!---The Internet has really brought back stick people and smileys out of bankruptcy. __Emote!__-->\n\n<h3>从哪里开始</h3>\n\n<p>那么，你也许会把Blurbs<sup>TM</sup>的主框架写入一个json文件中，对吧？\n但你如何监控界面的内容和它上传的时间呢？\n而当你加载了那个文件，在Ruby中它会以什么数据类型显示呢？\n会以哈希？或是数组？还是包含数组的数组？或是其他的一些什么？</p>\n\n<h3>类</h3>\n\n<p>我认为你会想要用类。你已经熟悉了很多类：\n哈希，数组，字符串。\n让我们创建一个新的类（不返回输出）：</p>\n\n<pre><code>class Blurb\nend\n</code></pre>\n","load_code":""},
"47":{"lang":"ZH","title":"App的内容","chapter":"N","answer":"","ok":"","error":"","text":"<p>你已经创建了一个新的Blurb<sup>TM</sup>类。你会怎样设计界面？\n信息Blurb<sup>TM</sup>的内容，当然。并且，发送的时间，还有情绪。</p>\n\n<p>好的，下面是Blurb类的余下定义：</p>\n\n<pre><code>class Blurb\n  attr_accessor :content, :time, :mood\nend\n</code></pre>\n\n<p>类的名称始终以大写字母为开头。</p>\n\n<p>（仍然没有输出）</p>\n","load_code":""},
"48":{"lang":"ZH","title":"存储器是悬空的星星的角","chapter":"N","answer":"Blurb:","ok":"我的第一个Blurb","error":"","text":"<p>嘿，不错的类。你已经有了一个新Blurb<sup>TM</sup>类。</p>\n\n<p>在类的定义中，你使用了attr_accessor方法。\n在类定义中有很多像这样的 <strong>attr（属）</strong>ibute（性)方法或者其他的一些小设定。\n这些属性是附着在类中的变量。</p>\n\n<p>这样，把类想象成一个五角星，那些属性就是星星的角，共同组成了它。</p>\n\n<h3>现在</h3>\n\n<p>创建一个Blurb<sup>TM</sup>并设定好内容:</p>\n\n<pre><code>blurb1 = Blurb.new\nputs blurb1\nblurb1.content = &quot;Today Mount Hood Was Stolen!&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :content,:time,:mood;end"},
"49":{"lang":"ZH","title":"一个对象，整洁的小包裹","chapter":"N","answer":"Blurb:","ok":"Blurb已更新","error":"","text":"<p>继续设置Blurb<sup>TM</sup>的时间和心情:</p>\n\n<pre><code>blurb1.time = Time.now\nblurb1.mood = :sick\n\nputs blurb1\n</code></pre>\n","load_code":"prev;blurb1=Blurb.new;blurb1.content=\"Today Mount Hood Was Stolen!\""},
"50":{"lang":"ZH","title":"让它更快","chapter":"N","answer":"^\\d{4}","ok":"Noted","error":"","text":"<p>不错，你的app很棒。嘿，让我们把这件事情简化一下。\n你不会每次发Blurb<sup>TM</sup>都想手动加一下时间的。</p>\n\n<p>每次只手动写内容和心情对吧？</p>\n\n<p>让我们把 <strong>initialize</strong> 方法增加到类中。这个方法在会在每条Blurb<sup>TM</sup>创建的时候都被调用。</p>\n\n<p>同时我们可以限制Blurb<sup>TM</sup>长度为40个字符。</p>\n\n<pre><code>class Blurb\n  attr_accessor :content, :time, :mood\n\n  def initialize(mood, content=&quot;&quot;)\n    @time    = Time.now\n    @content = content[0..39]\n    @mood    = mood\n  end\nend\n\nBlurb.new.time\n</code></pre>\n\n<p>(参数 <strong>content=&ldquo;&rdquo;</strong> 是为了确保即使没有content参数被传入初始化方法中，\ncontent也是字符串。)</p>\n","load_code":""},
"51":{"lang":"ZH","title":"你教会了你的app拒绝做无意义的事","chapter":"N","answer":"Blurb:","ok":"Blurb已添加","error":"","text":"<p>你注意到在类的内部我们使用了@（@time）吗？\n在类 <strong>之外</strong>，我们用存储器:</p>\n\n<blockquote>\n<p><strong>blurb.time = Time.now</strong></p>\n</blockquote>\n\n<p>但是在类 <strong>之内</strong> 我们用 <strong>对象的变量</strong>:</p>\n\n<blockquote>\n<p><strong>@time = Time.now</strong></p>\n</blockquote>\n\n<p>They&rsquo;re the exact same thing, but expressed in two different places of your program.\n这两种方式是等效的，只是在程序的不同地方表达了。</p>\n\n<h3>创建另一个Blurb<sup>TM</sup></h3>\n\n<p>当一个新的Blurb<sup>TM</sup>被创建了，初始化方法将被用来检查是否有新的参数传入。</p>\n\n<p>额，我们需要两个新参数:</p>\n\n<pre><code>Blurb2 = Blurb.new :confused, &quot;I can not believe Mt. Hood was stolen!&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :content,:time,:mood;def initialize(mood, content=\"\");@time=Time.now;@content=content[0..39];@mood=mood;end;end;blurb1=Blurb.new(:sick,\"Today Mount Hood Was Stolen!\")"},
"52":{"lang":"ZH","title":"长颈鹿没有偷总结 #7","chapter":"Y","answer":"","ok":"","error":"","text":"<p>啊哈，你已经到这了，还完完整整的嘛。我们仍将努力使你的app成为现实，\n但是现在，我们来回顾一下。</p>\n\n<h3>类</h3>\n\n<p>Everything in Ruby is some kind of object. Classes explain objects, how a certain object works.\nFor example, you made a few Blurb<sup>TM</sup> objects and these objects are explained in the Blurb\nclass.\nIn other words: you call them Blurb objects.\nYou can use classes to (kinda) model real life objects.\n在Ruby中，一切皆对象。类会解释一个特定的对象是怎么工作的。\n比如，你创建了几个Blurb<sup>TM</sup>对象并且在Blurb<sup>TM</sup>类中对其进行了解释。\n换句话说：你把他们叫做Blurb对象。\n你可以用类来搭建真实生活中的对象。</p>\n\n<h3>Accessors（存储器）</h3>\n\n<p>存储器是附着在对象中的可以在对象 <strong>外</strong> 被调用的变量。\n(blurb2.time = Time.now)</p>\n\n<h3>对象变量</h3>\n\n<p>对象变量就是用以存储器的变量，两者相同，但是在对象 <strong>内</strong>。\n(@time = Time.now)</p>\n","load_code":"prev;blurb2=Blurb.new :confused, \"I can not believe Mt. Hood was stolen!\""},
"53":{"lang":"ZH","title":"你自己的草场","chapter":"N","answer":"Blurbalizer:","ok":"我的app创建完成","error":"","text":"<p>好了，让我们把一切打包，孩子。接下来将是史诗般的Ruby冒险的最后一章！\n现在你已经对一切如何运行有了大概的理解，那如何把它们整合起来使用呢？\n你是一个很优秀的人（我最喜欢的人之一），但是你需要指引。</p>\n\n<h3>让我们完成你的app</h3>\n\n<p>你已经搭建了app的主框架，但还没有真正的app。\n你需要一个地方来保存Blurbs<sup>TM</sup>，和一个时间线来记录信息。</p>\n\n<p>想不到吧，我们要再创建一个类。我把新类的代码一次性全贴出来了。\n你可以 <strong>慢慢学习</strong>。\n我可不急，我在下一节课等你。</p>\n\n<pre><code>class Blurbalizer\n  def initialize(title)\n    @title  = title\n    @blurbs = [] # 用来储存Blurbs\n                 # 的新数组\n  end\n\n  def add_a_blurb(mood, content)\n    # 其中 &lt;&lt; 意为添加到数组尾部\n    @blurbs &lt;&lt; Blurb.new(mood, content)\n  end\n\n  def show_timeline\n    puts &quot;Blurbify: #{@title} has #{@blurbs.count} Blurbs&quot;\n\n    @blurbs.sort_by { |t|\n      t.time\n    }.reverse.each { |t|\n      puts &quot;#{t.content.ljust(40)} #{t.time}&quot;\n    }\n  end\nend\n\nmyapp = Blurbalizer.new &quot;The Big Blurb&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :content,:time,:mood;def initialize(mood, content=\"\");@time=Time.now;@content=content[0..39];@mood=mood;end;end"},
"54":{"lang":"ZH","title":"Blurb究竟是什么","chapter":"N","answer":"Today","ok":"展示所有的blurbs","error":"","text":"<p>你来了。想通了前面Blurbalizer<sup>TM</sup>类的代码了吗？</p>\n\n<blockquote>\n<p>在Blurbalizer<sup>TM</sup>类中有两个<strong>方法</strong> (add_a_blurb 和 show_timeline).\n你可以在类外调用这些方法，就如同存储器一样。</p>\n</blockquote>\n\n<p>是时候使用Blurbalizer<sup>TM</sup>了。我已经预载了一些Blurb，你可以自己创建你的。</p>\n\n<p>我们不直接创建Blurbs<sup>TM</sup>，而是通过Blurbalizer<sup>TM</sup>类中的\nadd_a_blurb <strong>方法</strong> 。这样我们可以确保所有的Blurbs<sup>TM&lt;/sup被储存在\nmyapp 对象中。</p>\n\n<pre><code>myapp.add_a_blurb :moody, &quot;Add Blurb here&quot;\n\nmyapp.show_timeline\n</code></pre>\n","load_code":"prev;class Blurbalizer;attr_reader :title;def initialize(title);@title=title;@blurbs=[];end;def add_a_blurb(mood, content);@blurbs << Blurb.new(mood, content);@blurbs.each {|t| t.time -= 73};end;def show_timeline;puts \"Blurbalizer: #{@title} has #{@blurbs.count} Blurbs\\n\";@blurbs.sort_by { |t| t.time}.reverse.each { |t| puts \"#{t.content.ljust(40)} #{t.time}\"};end;end;myapp = Blurbalizer.new \"The Big Blurb\";myapp.add_a_blurb :sick,\"Today Mount Hood Was Stolen!\";myapp.add_a_blurb :confused,\"I can not believe Mt. Hood was stolen!\";myapp.add_a_blurb :dazed,\"I am speechless!\";myapp.add_a_blurb :mad,\"It was stolen by a giraffe !!\";myapp.add_a_blurb :sad,\"I Left my Hoodie on the Mountain!\";myapp.add_a_blurb :mad,\"I am never going back to that mountain.\""},
"55":{"lang":"ZH","title":"一切都有关结合","chapter":"N","answer":":-","ok":"Moody!","error":"","text":"<p>用Ruby的简单部分可以创造出很美的东西，特别是当你把它们结合在一起产生新事物。\n我们做了一个类包含着类的app。而Ruby很擅长做这类事情。\n这就是面向对象编程。</p>\n\n<p>我们将要面对TryRuby <strong>最后的编程练习</strong>。 如果你想，你可以为Blurbalizer<sup>TM</sup>增加更多功能。</p>\n\n<p>也许你想把<strong>show_timeline</strong> 方法中的情绪用笑脸打印出来。\n你可以在Blurb<sup>TM</sup>类中添加一个 <em>moodify</em> 方法，\n然后在 <em>show_timeline</em> 方法中使用：</p>\n\n<pre><code>class Blurb\n  attr_accessor :content, :time, :mood\n\n  def initialize(mood, content=&quot;&quot;)\n    @time    = Time.now\n    @content = content[0..39]\n    @mood    = mood\n  end\n\n  def moodify\n    if    @mood == :sad\n      return &quot;:-(&quot;\n    elsif @mood == :happy\n      return &quot;:-)&quot;\n    # Add other moods here\n    end\n\n    # The default mood\n    &quot;:-|&quot;\n  end\nend\n\nclass Blurbalizer\n  def initialize(title)\n    @title  = title\n    @blurbs = []\n  end\n\n  def add_a_blurb(mood, content)\n    @blurbs &lt;&lt; Blurb.new(mood, content)\n  end\n\n  def show_timeline\n    puts &quot;Blurbalizer: #{@title} has #{@blurbs.count} Blurbs&quot;\n\n    @blurbs.sort_by { |t|\n      t.time\n    }.reverse.each { |t|\n      puts &quot;#{t.content.ljust(40)} #{t.time}&quot;\n    }\n  end\nend\n\nmyapp.show_timeline\n</code></pre>\n","load_code":"prev"},
"56":{"lang":"ZH","title":"总结#8，嘿放松你已经做的很棒了-总结","chapter":"Y","answer":"","ok":"","error":"","text":"<p>最后一个小节需要一点时间来消化，会教会你怎么使用Ruby的。</p>\n\n<p>如果你很享受，你可以在这里继续<a href=\"/playground\">TryRuby Playground</a>\n或者下载并安装Ruby:\n<a href=\"https://www.ruby-lang.org/en/downloads/\" target=\"_blank\">ruby-lang.org</a></p>\n\n<p>Ruby安装好了之后，你可以创建一个文件，命名为\n<em>my_first_program.rb</em>，如果有一个文本编辑器，打一些Ruby代码然后用下面的指令来运行：</p>\n\n<pre><code>ruby my_first_program.rb\n</code></pre>\n\n<p>有很多（免费）开发工具自带编辑器，文件浏览器和一个‘Ruby运行环境’</p>\n\n<h2>🎉庆祝一下🎉</h2>\n\n<p>你真的值得一个双层蛋糕➕双层糖霜，和一个家伙在你旁边弹双层吉他。\n我的意思是，你完成了，真的！毫无疑问，你已经是一个 <strong>官方认证的活跃的聪明的人!</strong>。</p>\n\n<h2>更多</h2>\n\n<p>这个网站中还有一些文章。它们能为你接下去的学习指引道路。</p>\n","load_code":"def ruby(f);puts \"Go to www.ruby-lang.org to download Ruby\";end;class K;attr_reader :rb;end;my_first_program=K.new"}}