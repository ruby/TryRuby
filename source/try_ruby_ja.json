{"1":{"lang":"JA","title":"30分ありますか? 今すぐRubyを試しましょう!","chapter":"Y","answer":"","ok":"","error":"","text":"<p>Rubyは日本発のプログラミング言語で、ソフトウェア開発に革命をもたらしています。</p>\n\n<p>Rubyの美しさはシンプルさと力強さの調和にあります。</p>\n\n<p>エディタ内でRubyのコードを書いて、次のボタンを使って移動できます。</p>\n\n<ul>\n<li><strong>Run</strong> &rarr; エディタ内のコードを実行する</li>\n<li><strong>Copy</strong> &rarr; 例のコードをエディタにコピーする</li>\n<li><strong>Next</strong> &rarr; 次のレッスンに進む</li>\n<li><strong>Back</strong> &rarr; 前のレッスンに戻る</li>\n</ul>\n\n<div class=\"foxes\"><strong>Next</strong> をクリックして学習をはじめましょう</div>\n","load_code":""},
"2":{"lang":"JA","title":"エディタを使う","chapter":"N","answer":"^\\d{1,}$","ok":"よくできました! 計算が実行されました。出力された結果は見えていますか？","error":"エディタで 2 + 6 と入力してください","text":"<p>下にあるエディタウィンドウにRubyのコードを入力し、 <strong>Run</strong> を押して実行されるのを見てみましょう!</p>\n\n<p>例として、以下の様な数式を入力してみてください。</p>\n\n<pre><code>2 + 6\n</code></pre>\n\n<p>プログラムの出力は、上にある出力ウィンドウに表示されます。\nまた正しくできたかどうかを表示する行もあります。</p>\n\n<blockquote>\n<p>あるいは、<strong>Copy</strong> ボタンを押して例のコードをエディタにコピーすることもできます。</p>\n</blockquote>\n","load_code":""},
"3":{"lang":"JA","title":"数と数式","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"よくできました","error":"","text":"<p>Rubyは数と数学記号を理解できます。以下のような数式も入力してみましょう。</p>\n\n<pre><code>4 * 10\n5 - 12\n30 / 4\n</code></pre>\n","load_code":""},
"4":{"lang":"JA","title":"異なる出力","chapter":"N","answer":"^[0-9\\.,-]{1,}$","ok":"正しく出力されました","error":"","text":"<p>数式をいくつか入力したのに、答えは最後の1つしか表示されなかったことに気づきましたか?\n何が起こっているのでしょうか?</p>\n\n<blockquote>\n<p>このWebサイトを使いやすくするため、プログラムの実行結果を\n上の出力用画面にコピーするようにしています。\nなので、数式を入力すると、その結果が見られます。\n<strong>しかし、それは最後の結果だけです。</strong> そして出力が空だったときのみです。</p>\n</blockquote>\n\n<p>2つ以上の数式を入力しても、Rubyは最後の数式の結果しか返してくれません。</p>\n\n<p>もちろん画面をコントロールすることもできます! それぞれの数式の前に <strong>puts</strong> と(間に空白を入れて)入力してみましょう。\nputsは <em>&lsquo;画面に何かを出力(put)する&rsquo;</em>　という意味になります。</p>\n\n<p>以下を試してみましょう。</p>\n\n<pre><code>puts 4 * 10\nputs 5 - 12\nputs 30 / 4\n</code></pre>\n\n<p>最後の数式のputsを削除して何が起こるか確認してみましょう。</p>\n","load_code":""},
"5":{"lang":"JA","title":"名前を言ってみる","chapter":"N","answer":"[a-zA-Z]{1,1}","ok":"完ぺきです。名前を表す文字から文字列を作り出しました","error":"","text":"<p>いいですね、コンピュータは計算を手軽にすばやく扱います。\n次に移りましょう。逆さまになった名前を見てみたくないですか？</p>\n\n<p>まず、引用符のなかにあなたの苗字を入力してみてください。次のような感じです。</p>\n\n<pre><code>&quot;Jimmy&quot;\n</code></pre>\n","load_code":""},
"6":{"lang":"JA","title":"名前を逆さまに言ってみる","chapter":"N","answer":"\\w+","ok":"たしまきでくよ","error":"","text":"<p>コンピュータが処理できる文字の集まりのことを文字列といいます。\n文字を一並びに干された洗濯物、引用符をその端をつまんでいる洗濯ハサミだと思ってください。\n引用符は文字列のはじめとおわりを表します。</p>\n\n<p>名前を逆さまにするには、つぎのように入力します。</p>\n\n<pre><code>&quot;Jimmy&quot;.reverse\n</code></pre>\n\n<p>(ピリオドを忘れないで！)</p>\n","load_code":""},
"7":{"lang":"JA","title":"文字数を数える","chapter":"N","answer":"^\\d+$","ok":"そのとおり。lengthも'メソッド'です","error":"","text":"<p>名前を逆さまにする <strong>メソッド</strong> を使いました！\nまず名前を引用符でくくり、文字列を作りました。\nそして文字列のreverseメソッドを呼び出しました。\nreverseメソッドは文字列のすべての文字を逆さまにひっくりかえす動きをします。</p>\n\n<p>それでは次に、名前が何文字かを表示させてみましょう。</p>\n\n<pre><code>&quot;Jimmy&quot;.length\n</code></pre>\n","load_code":""},
"8":{"lang":"JA","title":"繰り返す","chapter":"N","answer":"(\\w+)","ok":"こんにちわ。こんにちわ。こんにちわ。","error":"","text":"<p>文字数が数えられると、どんないいことがあるの？と疑問に思っているかもしれません。</p>\n\n<p>ええと、Webサイトで <strong>パスワードが短すぎます！</strong> と警告されたことがあるでしょう。</p>\n\n<p>そうした場面では、プログラムの中で <strong>.length</strong> メソッドが使われていることがあります。</p>\n\n<p>次に進みましょう。名前に5を掛けてみてください。</p>\n\n<pre><code>&quot;Jimmy&quot; * 5\n</code></pre>\n","load_code":""},
"9":{"lang":"JA","title":"このくらいで要約（その1）にしましょう","chapter":"Y","answer":"NoMethodError|undefined","ok":"いいえ、数を逆さまにはできません。'Next'を押してください","error":"","text":"<p>ここまでの数分で学んだことを確認してみましょう。</p>\n\n<h3>エディタ</h3>\n\n<p>エディタにコードを入力しRunを押すと、出力ウィンドウに結果が出力されます。\nほぼすべてのコードは、結果が表示されます。</p>\n\n<h3>数値と文字列</h3>\n\n<p>数値と文字列は、Rubyで計算やテキスト処理を行うためのオブジェクトです。</p>\n\n<h3>メソッド</h3>\n\n<p>reverseやlengthといった英語のメソッドを使いました。\nそれと、乗算メソッド(*)のような記号のメソッドも使いました。\n<strong>メソッドは振る舞いを意味します！</strong></p>\n\n<p>ここまでやってきたことが学習の本質です。\nシンプルな物事を取り上げていじくり回すと、それらは新しい物事に変わります。\n快適に進められていますか？そうであるよう望みます。</p>\n\n<h2>オーケー</h2>\n\n<p>ちょっとだけ不快なことをしてみましょう。数を逆さまにしてみてください。</p>\n\n<pre><code>40.reverse\n</code></pre>\n","load_code":""},
"10":{"lang":"JA","title":"止めて！おかしくなってしまったの？","chapter":"N","answer":"^\\d{1,}$","ok":"逆さまにできるのは文字列だけです","error":"","text":"<p>40という数を逆さまにはできません。\nモニタを鏡に向けて持ち上げることができるかもしれませんが、数字を逆さまにするということは理にかなっていません。</p>\n\n<p>Rubyはエラーメッセージを投げます。Rubyは数値を逆さまにするメソッドがないことを伝えています。</p>\n\n<p>あるいは、数値をまず文字列に変換すると良いかもしれません。</p>\n\n<pre><code>40.to_s.reverse\n</code></pre>\n","load_code":""},
"11":{"lang":"JA","title":"男の子とちがう女の子って","chapter":"N","answer":"\\[\\]","ok":"素晴らしい。これは空のリストです。","error":"","text":"<p>数値は文字列と異なります。</p>\n\n<p>Rubyでは任意のオブジェクトのメソッドを使用できますが、いくつかのメソッドは特定の種類でだけ動きます。\nけれど、Rubyの&quot;to&quot;メソッドを使えば、いつでもデータの種類を変換できます。</p>\n\n<ul>\n<li><strong>to_s</strong> はデータを文字列(<strong>s</strong>tring)に変換します</li>\n<li><strong>to_i</strong> はデータを整数(<strong>i</strong>nteger)に変換します</li>\n<li><strong>to_a</strong> はデータを配列(<strong>a</strong>rray)に変換します</li>\n</ul>\n\n<p><strong>配列って何？！</strong></p>\n\n<p>配列とはリストのことです。次のように、角かっこの対を入力してみてください。</p>\n\n<pre><code>[]\n</code></pre>\n","load_code":""},
"12":{"lang":"JA","title":"一列に並んで","chapter":"N","answer":"^\\[([-\\.\\d]+)(\\s*,\\s*[-\\d\\.]+){3,}\\]$","ok":"バッチリです","error":"リストの4番目に数値を追加してください","text":"<p>リスト（配列）は<strong>決まった順序で</strong>ものを格納します。</p>\n\n<p>ポップコーンを買うために一列に並ぶようなものです。\nあなたは誰かの後ろに並んでいて、前にいる人たちを脇に押しやろうとは夢にも思っていません。ですよね？\nそして、後ろに並んでいる誰かにあなたは目を光らせている。でしょう？</p>\n\n<p>次に示すのは、あなた専用のリストです。抽選番号のリストです。</p>\n\n<pre><code>[12, 47, 35]\n</code></pre>\n\n<p>このリストに数を1つ追加してください。\n35のあとにカンマを入力し、続いて数を入力します。\n空白を入力するかどうかは任意です。</p>\n","load_code":""},
"13":{"lang":"JA","title":"だれか手を挙げて","chapter":"N","answer":"^47$","ok":"オーケー","error":"","text":"<p>抽選番号のリストがあります。いちばん大きな値はどれでしょう？</p>\n\n<p>以下を試してみてください。</p>\n\n<pre><code>[12, 47, 35].max\n</code></pre>\n","load_code":""},
"14":{"lang":"JA","title":"リストをしまい込む","chapter":"N","answer":"^\\[(\\d+)(,\\s*\\d+){2,}\\]$","ok":"保存しました！","error":"","text":"<p>いい調子です。けれど、必要になるたびにリストを打ち直すのは気が滅入りますよね。</p>\n\n<p>ticketにリストを保存しましょう。次のようにします。</p>\n\n<pre><code>ticket = [12, 47, 35]\n</code></pre>\n","load_code":""},
"15":{"lang":"JA","title":"ticketと入力してみる","chapter":"N","answer":"\\[(\\d+(, )?){2,}\\]","ok":"元の状態でした！","error":"","text":"<p>では、入力してみましょう。</p>\n\n<pre><code>ticket\n</code></pre>\n","load_code":"ticket = [12, 47, 35]"},
"16":{"lang":"JA","title":"保存して、しまい込みました","chapter":"N","answer":"\\[12, 35, 47\\]","ok":"リストをソートしました","error":"","text":"<p>抽選番号をメモし、それをticketという名前の<strong>変数</strong>にしまい込みました。\nここで、変数の名前は<em>jimmyslist</em>のような別のものでも構いません。</p>\n\n<p>プログラミングとは、これからわかってくることだと思いますが、\nおおむね変数とうまくやるということです。</p>\n\n<p>次に抽選番号を整列させてみましょうか。どうです？</p>\n\n<p>やり方は次の通りです。</p>\n\n<pre><code>ticket.sort!\n</code></pre>\n\n<p>リストを整列(sort)しました。変数ticketはもう変わっています。\n<em>sort!</em>メソッドのさいごに、大きく目立つ感嘆符があるのに気づきましたか？\nRubyのメソッドは、しばしば変数の中身を変更してしまう時にこのように叫びます。\nですがこれは何てことはない、ただの印です。</p>\n","load_code":"ticket = [12, 47, 35]"},
"17":{"lang":"JA","title":"要素","chapter":"N","answer":"^(12|35|47)$","ok":"いいですね","error":"惜しい","text":"<p>抽選番号をticketという変数に格納していました。それを再び取り出すにはどうしたらよいでしょう？</p>\n\n<p>もっとも大きな数を<strong>max</strong>を使って取り出す方法はすでに確認しました。\n同じように、<strong>first</strong>や<strong>last</strong>というメソッドを使えば、リストの最初(first)の要素や最後(last)の要素を取り出すことができます。\nけれど、特定の要素を取り出したい場合は？</p>\n\n<h3>[ ]</h3>\n\n<p>Rubyは対象の要素を指すのに角かっこ [ ] を使います。\n角かっこはRubyでよく使われます。\n対象を並べるために使われる道しるべのようなものです。\n角かっこは「___を探しています」と対象に照準を合わせることを意味します。</p>\n\n<p>すべての抽選番号を得るには、次のようにします。</p>\n\n<pre><code>puts ticket[0]\nputs ticket[1]\nputs ticket[2]\n</code></pre>\n\n<p>[0]、[1]、[2]を使ったのはどうしてでしょう？</p>\n\n<p>そして、なぜ[1]、[2]、[3]ではないのでしょう？\n禅か何かの影響？そうではありません。\nわたしたちコンピュータの使い手は、0から数え始めるものなのです。けっしてRubyに限ったことではありません。\nこの<strong>0オリジン</strong>の数え方はほとんどのプログラミング言語で使われています。</p>\n\n<blockquote>\n<p>忘れていませんか: <strong>Copy</strong>ボタンを使えば例のコードをエディタに貼り付けることができます。</p>\n</blockquote>\n","load_code":"ticket = [12, 47, 35]"},
"18":{"lang":"JA","title":"要約（その2）がやって来ました","chapter":"Y","answer":"\\w+","ok":"韻を踏んでいますか？","error":"","text":"<p>では、ここまでの数分をどう過ごしたか確認しましょう。</p>\n\n<h3>エラー</h3>\n\n<p>数値や疑わしげなものを逆順にしようとした場合には、Rubyはエラーが起きたことを教えてくれます。</p>\n\n<h3>配列</h3>\n\n<p>配列とは、決まった順序でものを格納するためのリスト構造です。\n配列の作成の仕方と、配列から要素を取り出す方法を学びました。</p>\n\n<h3>変数</h3>\n\n<p>変数はものを保存し、それに名前を与えます。変数に何かを格納するには、\nticket = [14, 37, 18] のように等号を使います。</p>\n\n<h3>2/8</h3>\n\n<p>このチュートリアルは全部で8つの章から構成されています。\nここまでで全体の８分の２まで進んできました！そんな複雑じゃないでしょう？\nいい調子です。</p>\n\n<p>少し話題を変えましょう。ある変数に、あなたに向けたちょっとしたポエムを詰めておきました。\n次のように入力して、見てみてください。</p>\n\n<pre><code>puts poem\n</code></pre>\n","load_code":"poem = \"My toast has flown from my hand\\nAnd my toast has gone to the moon.\\nBut when I saw it on television,\\nPlanting our flag on Halley's comet,\\nMore still did I want to eat it.\\n\""},
"19":{"lang":"JA","title":"悲しいかな、トーストの詩が大嫌い","chapter":"N","answer":"(toast){0}","ok":"すばらしい","error":"まだトーストの匂いがします","text":"<p>ええ、大丈夫です。無理に好きになる必要はありません。お好きなようにハックしてください。\nトーストの代わりに、メロンや他の何かを使いましょう。\n新しい詩を確認するために、次のコードを試してください。</p>\n\n<pre><code>poem.gsub(&quot;toast&quot;, &quot;honeydew&quot;)\n</code></pre>\n\n<p><strong>gsub</strong>メソッドはグローバル置換(global substitute)の略です。\n上記はすべての&quot;toast&quot;を&quot;honeydew&quot;と置き換えます。</p>\n","load_code":"prev"},
"20":{"lang":"JA","title":"構えて、狙って","chapter":"N","answer":"^\\n.ti tae ot (.+)","ok":"オーケー。詩全体が逆順に変わりました。","error":"","text":"<p>ここで質問があります。\nこの詩を丸ごと逆順にしたらどうなるでしょうか？</p>\n\n<pre><code>poem.reverse\n</code></pre>\n","load_code":"prev"},
"21":{"lang":"JA","title":"ひっくり返し過ぎました","chapter":"N","answer":"^\\[\"More still did (.+)","ok":"いいですね、だいたい実現できました","error":"","text":"<p>句読点なども含めて、詩全体が逆順となってしまいました。\n本当は行の順序をひっくり返したかったのです。\n最後の行を最初に、最初の行は最後にするということです。</p>\n\n<p>行は逆順にしますが、文自体は逆順に<strong>しません</strong>。</p>\n\n<p>どうやるかを次に示します。</p>\n\n<pre><code>poem.lines.reverse\n</code></pre>\n","load_code":"prev"},
"22":{"lang":"JA","title":"メソッドをつなげる","chapter":"N","answer":"^More still did (.+)","ok":"いい感じですね！joinメソッドは、配列の各要素をつなげて、一つの文字列にしました。","error":"","text":"<p>何が確認できました？いったい何が起こりました？<strong>poem.lines.reverse</strong>と入力すると、何が起きたでしょう？</p>\n\n<p>2つのことが起きました。linesを使って、詩を行ごとのリストにしました。\nlinesは文字列を分解する方法を決定し、配列に変換します。</p>\n\n<p>では、さらにもう一つメソッドをつなげてみましょう。</p>\n\n<pre><code>puts poem.lines.reverse.join\n</code></pre>\n\n<p>このようにメソッドをつなげていくことを、<strong>メソッド連鎖</strong>といいます。</p>\n","load_code":"prev"},
"23":{"lang":"JA","title":"ここで、要約（その3）です","chapter":"Y","answer":"\\{\\}","ok":"空のハッシュを作成しました！","error":"","text":"<h3>感嘆符</h3>\n\n<p>メソッドには、名前に感嘆符（もしくは疑問符）がつくものがあります。\nそれらは、メソッドがどんな動きをするかを説明するためについているもので、どうということはありません。</p>\n\n<h3>文字列操作</h3>\n\n<p>文字列を検索し、置換しました。</p>\n\n<h3>連鎖</h3>\n\n<p>メソッド連鎖をすると、より多くのことを一気におこなえます。\n詩を分割し、逆順にし、ふたたび組み立てるために、<strong>poem.lines.reverse.join</strong>としました。</p>\n\n<p>もしかすると、もうちょっと詩をいじくってみたいですか？\nStringのすべてのメソッド一覧は<a href=\"http://ruby-doc.org/core/classes/String.html\" target=\"_blank\">ここ</a>にあります。</p>\n\n<p>見に行ってみて、ちょっとだけ試してみてください。\npoem.downcaseやpoem.swapcaseなどをしてみると面白いかもしれません。</p>\n\n<h2>準備はいいですか？</h2>\n\n<p>次に行く準備が整ったら、次のように入力してください。</p>\n\n<pre><code>books = {}\n</code></pre>\n","load_code":"prev"},
"24":{"lang":"JA","title":"ちっちゃな空っぽの本","chapter":"N","answer":"^(splendid|quite_good|mediocre|quite_not_good|abysmal)$","ok":"新しい書評です","error":"splendid、quite_good、mediocre、quite_not_good、abysmal<br/>のいずれかを使ってください。また、コロンを忘れないでください","text":"<p>今作成したのは空の<strong>ハッシュ</strong>です。ハッシュは配列みたいなもので、各要素が名前を持つという点が異なります。</p>\n\n<p>新しいハッシュに簡易的な書評をいくつか詰め込んでみることにします。\n評価体系は次のとおりです。</p>\n\n<ul>\n<li>:splendid &rarr; とてもよい</li>\n<li>:quite_good &rarr; よい</li>\n<li>:mediocre &rarr; よい部分とひどい部分が半々</li>\n<li>:quite_not_good &rarr; よくない</li>\n<li>:abysmal &rarr; これはひどい</li>\n</ul>\n\n<p>書籍を評価するために、角かっこの中に書名を置き、イコールの後に評価結果を置きます。\n以下に例を示します。</p>\n\n<pre><code>books[&quot;Gravitys Rainbow&quot;] = :splendid\n</code></pre>\n\n<blockquote>\n<p>TryRubyのすべてのレッスンが互いに独立していることについて、そろそろ触れないといけないでしょう。\nこのレッスンでものすごくたくさん書評を入力したとしても、それはこのレッスンでだけしか使えません。\nもし次のレッスンでも作成した書評を使いたいのなら、書評をコピーしておいて次のレッスンにてペーストしてください。\n心配しすぎなくても大丈夫です。レッスンを楽しめるように、各レッスンで必要となるものは、事前にきちんと定義されています。</p>\n</blockquote>\n","load_code":"books = {}"},
"25":{"lang":"JA","title":"一口書評をもうちょっと","chapter":"N","answer":"[3-9]","ok":"lengthメソッドは文字列だけでなく、配列やハッシュでも使えます","error":"","text":"<p>つづけて書評を増やしていきましょう。\nすべてのリストを確認するには、<strong>puts books</strong> と入力します。</p>\n\n<p>繰り返しますが、評価体系は :splendid、:quite_good、:mediocre、:quite_not_good、:abysmal です。</p>\n\n<p>これらの評価は文字列ではありません。単語の前にコロンをつけると、それは<strong>シンボル</strong>になります。\nシンボルとは、コンピュータメモリの観点で、文字列よりもコストの安いものになります。\nもしプログラムの中で繰り返し繰り返し同じ単語を使いっていたら、シンボルを使うべきです。\nその単語の数千のコピーをメモリ上に持つのではなく、コンピュータは<strong>一度</strong>だけシンボルを格納します。</p>\n\n<p>もっと重要なことは、シンボルにすることは、それが適当な単語ではなく、プログラム中で意味があると示すことができるということです。</p>\n\n<p>書評を2つ以上入力したら、<strong>books.length</strong>を使ってハッシュの中に何この書評があるかを確認してみてください。</p>\n\n<pre><code>books[&quot;The deep end&quot;]  = :abysmal\nbooks[&quot;Living colors&quot;] = :mediocre\n\nputs books\n\nputs books.length\n</code></pre>\n","load_code":"books = {\"Gravitys Rainbow\" => :splendid}"},
"26":{"lang":"JA","title":"待って。Gravity's Rainbowは好きでしたっけ？","chapter":"N","answer":"^(splendid|quite_good|mediocre|quite_not_good|abysmal)$","ok":"とても好きでした","error":"","text":"<p>Rubyがすばらしい点のひとつに、名前がしばしば再利用されるという点があります。\nこのおかげで、覚えておかないとならない名前は少なくなります。</p>\n\n<p>配列から要素を取り出す際は、<strong>puts ticket[1]</strong> のように数値を使う必要があったのを覚えてますか？</p>\n\n<p>ハッシュでも同様の方法で要素を取り出せます。ただし、数値ではなく名前を使用します。</p>\n\n<p>古い書評を調べたくなったとします。ふたたび角かっこに書名を入力しましょう。けれどイコールから後ろは含めないでください。\n次のようになります。</p>\n\n<pre><code>puts books[&quot;Gravitys Rainbow&quot;]\n</code></pre>\n","load_code":"books = {\"Gravitys Rainbow\" => :splendid, \"The deep end\" => :abysmal, \"Living colors\" => :mediocre}"},
"27":{"lang":"JA","title":"ハッシュはペア","chapter":"N","answer":"^\\[\".*\"\\]","ok":"キーを取り出しました","error":"","text":"<p>気をつけないといけないことがあります。ハッシュは順序を保持しません。\nそれはハッシュの責務ではないからです。ハッシュはただ二つのものをペアにします。\n<strong>キー</strong>と<strong>値</strong>です。</p>\n\n<p>書評を詰め込んだハッシュで言うと、書名がキーで評価が値です。</p>\n\n<p>もし評価した書籍の書名だけをすべて確認したいだけなら、次のようにします。</p>\n\n<pre><code>books.keys\n</code></pre>\n\n<p>.keysの代わりに.valuesを試すこともできます。</p>\n","load_code":"prev"},
"28":{"lang":"JA","title":"辛辣な書評をつけてしまった？","chapter":"N","answer":"\"mediocre\"","ok":"やった！すごいです。評価のスコアカードを作成しました","error":"","text":"<p>辛辣か不公平な書評をつけてしまいましたか？\nでは、<strong>ratings</strong>という新しいハッシュを用意してスコアをつけていくようにしましょう。</p>\n\n<p>どうするかというと、そうですね、書評をカウントアップしていくことにします。以下を入力してください。</p>\n\n<pre><code>ratings = Hash.new {0}\n\nbooks.values.each { |rate|\n  ratings[rate] += 1\n}\n\nputs ratings\n</code></pre>\n\n<p>コード中の棒線はパイプ文字です。キーボードだと、Enterキーの上あたりにあるはずです。</p>\n\n<p>このコードの<em>+= 1</em>という行は、値を1増やすという意味になります。</p>\n\n<p>ここで起きていることをぜんぶ理解できないとしても、心配しないでください。\nあとで明らかにしていきます。</p>\n","load_code":"books = {\"Gravitys Rainbow\" => :splendid, \"The deep end\" => :abysmal, \"Living colors\" => :mediocre, \"Bumblebees\" => :mediocre}"},
"29":{"lang":"JA","title":"数え上げる","chapter":"N","answer":"\\w+","ok":"Yodelay!","error":"","text":"<p>たったいま使った、驚くべき新しい道具は<strong>ブロック</strong>です。\nここから2つのレッスンでは、ブロックについて詳しく見ていくことにします。\n基本的に、ブロックとは中かっこでくくられたRubyのコード片のことです。</p>\n\n<p>では、別のブロックも試してみましょう。</p>\n\n<pre><code>5.times { print &quot;Odelay! &quot; }\n</code></pre>\n\n<p>ブロックは常にメソッドに渡されます。\n<strong>times</strong>メソッドのように、ブロックをとり、そのコード片を何回も実行したりします\n（上記の例は5回でした）。</p>\n","load_code":""},
"30":{"lang":"JA","title":"いまはいくつ？","chapter":"N","answer":"^[0-9]$","ok":"ちょうど良い回数、ブロックを実行しました！","error":"ブロックは0から9までの間で実行させてください","text":"<p>ブロックを使った最初の例（評価をカウントしたプログラムです）で見たように、ブロックには値を渡すことができます。\nどんな値が<strong>渡される</strong>かは、ブロックを実行するメソッドによって決定されます。</p>\n\n<p>ブロックが<strong>受け取った</strong>値は、ブロックのはじめ、二つのパイプ文字（|）の間にある変数に置かれます。</p>\n\n<p>次のブロックを使ったコードを試してみてください。</p>\n\n<pre><code>5.times { |time|\n  puts time\n}\n</code></pre>\n\n<p>ここでは、<strong>.times</strong>メソッドは変数<strong>|time|</strong>に値を送ります。\ntime変数はブロックの中でしか参照できないということに注意してください。</p>\n\n<blockquote>\n<p>ブロックのコードを複数行に分けて書くことができることに気づきましたか？こうすると、ちょっとばかりコードを読みやすくできます。</p>\n</blockquote>\n","load_code":""},
"31":{"lang":"JA","title":"要約（その4）にたどり着きました","chapter":"Y","answer":"","ok":"","error":"","text":"<p>最後のレッスンはちょっと長かったかもしれません。\n以下のことを学ぶのに、だいたい3分くらいかかったでしょうか。</p>\n\n<h3>ハッシュ</h3>\n\n<p>ねじれたページ<strong>{}</strong>を持つ小さな辞書です。</p>\n\n<h3>シンボル</h3>\n\n<p>とても小さく効率的なコードで、<strong>:splendid</strong>のようにコロン付きの単語で表します。</p>\n\n<h3>ブロック</h3>\n\n<p>多くのRubyのメソッドに付け加えることができるコード片です。\nスコアカードを組み立てるために使ったコードは、次のようなものでした。\n<strong>books.values.each { |rate| ratings[rate] += 1 }</strong></p>\n\n<h3>次</h3>\n\n<p>次のレッスンではメソッドの内部についてもう少し深く掘り下げていこうと思います。</p>\n","load_code":""},
"32":{"lang":"JA","title":"生きるべきか死ぬべきか","chapter":"N","answer":"","ok":"","error":"","text":"<p>これまできちんと話してこなかったちょっとしたことの一つに、メソッド引数があります。\n詩をちょっとばかり書き換えた時のことを覚えていますか？次のようなコードを書きました。\n<strong>poem.gsub(&ldquo;toast&rdquo;, &ldquo;honeydew&rdquo;)</strong></p>\n\n<p>gsubメソッドは2つの引数を必要とします。上記では、丸かっこの間に2つの文字列を含めることで\ngsubにその引数を渡しています。\n<em>引数はやりたいことをメソッドに伝えるためにあります。</em></p>\n\n<h3>丸かっこ</h3>\n\n<p>実のところ、丸かっこを省略したとしても、ほとんどの場合Rubyは気にしません。\nですので、次のように書くこともできます。\n<strong>poem.gsub &ldquo;toast&rdquo;, &ldquo;honeydew&rdquo;</strong></p>\n\n<p>これまでも、他のメソッドをパラメータと一緒に使ってきました。\n実際には何回も使っています。けれど、まったく明白ではありませんでした。\n例えば、以下のように。</p>\n\n<pre><code>puts &quot;Hello&quot;\nputs(&quot;Hello&quot;)\n</code></pre>\n\n<p>そうです。<strong>puts</strong>もまたメソッドです。\nputsをかっこ有りで使っても、かっこ無しで使っても、Rubyは同じように扱います。\nけれど、かっこ無しの方がちょっとだけ読みやすいですね。そして、入力する時間も節約できます！</p>\n\n<blockquote>\n<p>逆に、コードがいい感じに読みやすいのであれば、かっこ有りで書くことだって自由です。</p>\n</blockquote>\n\n<h3>to (be) or not to (be): 生きるべきか死ぬべきか</h3>\n\n<p><em>する(to)</em>がメソッドで、<em>ある状態(be)</em>が引数であれば、古くからのこの質問の答えも明らかです。\n大事なのは、<em>生きる</em>あるいは<em>(ある状態に)する</em>ことを優先するかどうかだけなのです。</p>\n\n<p>シェイクスピアの気分になりましたか？読んでいきましょう。</p>\n","load_code":"poem = \"My toast has flown from my hand\\nAnd my toast has gone to the moon.\\nYada yada yada\\n\""},
"33":{"lang":"JA","title":"じゃじゃ馬ならし","chapter":"N","answer":"^tame","ok":"よいです！","error":"","text":"<p>Rubyの使い方はもう完全にわかりました。つまり、必要な道具はすべて手に入れたということです。\nあとは、よりたくさんのメソッドについて学び、より複雑な問題に挑戦していく必要があります。</p>\n\n<p>ですが、まだ決着していないRubyの別の側面があります。独自のメソッドを作るということです。\n<strong>エヘン！</strong>それでは、次にそのやり方を学んでいきましょう。</p>\n\n<p>（putsやsort、timesなどの）Rubyの組み込みメソッドを使うこととは別に、独自のメソッドを定義することもできます。\nそれができると、何が嬉しいのでしょう？独自のメソッドを定義すると良い理由は、主に2つあります。</p>\n\n<h3>プログラムを短くするため</h3>\n\n<p>同じことをプログラム内のいろんな場所で行う必要があるとき、メソッドに分割してそのコードを配置します。\nコードはより短くなるはずです。</p>\n\n<h3>コードを読みやすくするため</h3>\n\n<p>プログラムで別々のことをたくさん行う必要があるとします。\nそれを一つの長いコードに詰め込むことも<strong>できます</strong>。\nけれど、それは後で読んだときに、とても読みにくく、理解しづらいものになってしまうでしょう。</p>\n\n<p>代わりに、コードを別々のメソッドに分割し、それぞれのメソッドに理解しやすい名前を与えましょう。\n後になって、それに感謝する時が来るはずです。</p>\n\n<p>では、どうやってメソッドを定義したらいいでしょう？それには、次のようにします。</p>\n\n<pre><code>def tame( number_of_shrews )\nend\n</code></pre>\n","load_code":""},
"34":{"lang":"JA","title":"RubyでDef Leppardと書くとLeppardメソッドの定義になる","chapter":"N","answer":"^tame","ok":"ならしても、ダメにしない","error":"","text":"<p>大丈夫です。ちゃんとできました。あなたは独自のメソッドを定義しました。\ndefに続いて、メソッドの名前を書きます。\nそして、必要な場合は、その後に引数のリストを書きます。\nけっして怖くないですし、危なくもありません！\nすべきことは、中身をRubyのコードで埋めて最後にendで終わることです。</p>\n\n<p>以下に例を示します。</p>\n\n<pre><code>def tame( number_of_shrews )\n  number_of_shrews.times {\n    puts &quot;じゃじゃ馬をならしました&quot;\n  }\nend\n</code></pre>\n\n<blockquote>\n<p><strong>補足</strong><br>\nこの章のタイトルにピンとこなかったでしょうか。\n<a href=\"https://ja.wikipedia.org/wiki/デフ・レパード\" target=\"_blank\">Def Leppard</a>\nはかつて有名だったイギリスのロックバンドです。</p>\n</blockquote>\n","load_code":""},
"35":{"lang":"JA","title":"作成した熟成フルーツ","chapter":"N","answer":"^じゃじゃ馬をならしました","ok":"飼いならされたじゃじゃ馬たちです","error":"","text":"<p>新しいメソッドが誕生しました。さっそく使ってみましょう。</p>\n\n<pre><code>tame 5\n</code></pre>\n","load_code":"def tame(number_of_shrews);number_of_shrews.times{puts \"じゃじゃ馬をならしました\"};end;"},
"36":{"lang":"JA","title":"ギブアンドテイク","chapter":"N","answer":"\\d+","ok":"いいです！ブラボー","error":"","text":"<p>ほとんどのメソッドは、入力として複数のパラメータを必要とするだけでなく、<strong>何かしらの値を戻します</strong>。\n先ほどのメソッドを少し変更して、戻り値を返すようにしました。以下を試してみてください。</p>\n\n<pre><code>def tame( number_of_shrews )\n  number_of_shrews.times {\n    puts &quot;Tamed a shrew&quot;\n  }\n  return number_of_shrews\nend\n\nputs tame(3)\n</code></pre>\n\n<h3>return</h3>\n\n<p>ここまでだいぶ先に進んできて、いろいろわかるようになってきたかと思います。ですので、ここではもう一つ別のヒントを出すことにしましょう。\n上記のメソッドからは<strong>return</strong>という単語は省略できます。\nRubyはメソッド内で評価された最後の値を自動的に返します。</p>\n\n<p>ですので、わたしたちは最後の行を<strong>number_of_shrews</strong>のように変更できます。</p>\n\n<p>なのですが、実は<strong>.times</strong>メソッドもまた<em>number_of_shrews</em>を返すので、最後の行をまったく取り除いてしまうことも可能です。つまり、実際には最初の実装でやりたかったことはすべてできてしまっていたのです！</p>\n","load_code":""},
"37":{"lang":"JA","title":"やあ、誰がいますか？要約（その5）が帽子を振っています","chapter":"Y","answer":"","ok":"","error":"","text":"<p>よくやりました、よくやりました、よくやりました！</p>\n\n<p>ほんとうに、ほんとうに、ほんっとおぉぉぉぉぉに！</p>\n\n<p>人生のもっとも直近の数分であなたがやったことを、ここでおさらいしましょう。</p>\n\n<h3>メソッド</h3>\n\n<p>メソッドは<strong>def</strong>のあとに名前を続けて定義します。\nメソッドはプログラムを短く、読みやすくできます。</p>\n\n<h3>引数</h3>\n\n<p>メソッドは引数を持てます。</p>\n\n<h3>戻り値</h3>\n\n<p>メソッドは（だいたいの場合）値を返します。</p>\n\n<h2>今</h2>\n\n<p>生きるべきか死ぬべきかはもう疑問ではなくなりました。\nシェイクスピアをもっと読む準備はできましたか？</p>\n","load_code":""},
"38":{"lang":"JA","title":"世界はあなたの思いのまま","chapter":"N","answer":"^\\{\\\"William","ok":"いいですね。けれど少しばかり読みにくいです。","error":"","text":"<p>ここまでは、自分自身で入力したものだけを使用するプログラムを実行してきました。\nそのことはよいのですが、それは言わば古い時代にあった叙事詩のようなものです。\nけれど、今はインターネット時代です。\nプログラミングの成果に、世界の残りを含めてもいい時代です。</p>\n\n<p>わたしたちは、とてもとてもたくさんのWebサイトを利用して、情報を要求することができます。\nたとえば、このリンクからはRubyに関する現在の<a href=\"http://news.google.com/news/section?q=ruby&output=rss\" target=\"_blank\">Googleニュースフィード</a>が手に入ります。</p>\n\n<p>Webブラウザは、おそらくとても良い感じにそれを表示してくれるでしょう。\nソースを表示したならば、奇妙にフォーマットされたテキストの長い文字列を確認できるはずです。\n先ほどのGoogleニュースフィードの例であれば、それは<strong>rss</strong>フォーマットというものになります。</p>\n\n<h3>フォーマット（形式）</h3>\n\n<p>Web上には、変わった名前を持ったとてもたくさんのフォーマットが存在し、利用されています。\nたとえば、htmlやxml、jsonといったフォーマットがあります。\nそうです、まさにこのWebサイトでも、これらのフォーマットを使用しています。</p>\n\n<p>試しに、インターネット上からウィリアム・シェイクスピアの全著作のリストを取得してくるメソッドを用意しました\n（実際にはこのWebサイトをホストしているサーバ上から取得してくるようにしています。誰にも迷惑はかかりませんので、ご安心ください）。</p>\n\n<p>データを取得するには、次のようにします。</p>\n\n<pre><code>get_shakey\n</code></pre>\n","load_code":"def get_shakey;JSON.parse(\"{\\\"William Shakespeare\\\": {\\\"1\\\": {\\\"title\\\": \\\"The Two Gentlemen of Verona\\\", \\\"finished\\\": 1591},\\\"2\\\": {\\\"title\\\": \\\"The Taming of the Shrew\\\", \\\"finished\\\": 1591},\\\"3\\\": {\\\"title\\\": \\\"Henry VI, Part 2\\\", \\\"finished\\\": 1591},\\\"4\\\": {\\\"title\\\": \\\"Henry VI, Part 3\\\", \\\"finished\\\": 1591},\\\"5\\\": {\\\"title\\\": \\\"Henry VI, Part 1\\\", \\\"finished\\\": 1592},\\\"6\\\": {\\\"title\\\": \\\"Titus Andronicus\\\", \\\"finished\\\": 1592},\\\"7\\\": {\\\"title\\\": \\\"Richard III\\\", \\\"finished\\\": 1593},\\\"8\\\": {\\\"title\\\": \\\"Edward III\\\", \\\"finished\\\": 1593},\\\"9\\\": {\\\"title\\\": \\\"The Comedy of Errors\\\", \\\"finished\\\": 1594},\\\"10\\\": {\\\"title\\\": \\\"Love's Labour's Lost\\\", \\\"finished\\\": 1595},\\\"11\\\": {\\\"title\\\": \\\"Love's Labour's Won\\\", \\\"finished\\\": 1596},\\\"12\\\": {\\\"title\\\": \\\"Richard II\\\", \\\"finished\\\": 1595},\\\"13\\\": {\\\"title\\\": \\\"Romeo and Juliet\\\", \\\"finished\\\": 1595},\\\"14\\\": {\\\"title\\\": \\\"A Midsummer Night's Dream\\\", \\\"finished\\\": 1595},\\\"15\\\": {\\\"title\\\": \\\"King John\\\", \\\"finished\\\": 1596},\\\"16\\\": {\\\"title\\\": \\\"The Merchant of Venice\\\", \\\"finished\\\": 1597},\\\"17\\\": {\\\"title\\\": \\\"Henry IV, Part 1\\\", \\\"finished\\\": 1597},\\\"18\\\": {\\\"title\\\": \\\"The Merry Wives of Windsor\\\", \\\"finished\\\": 1597},\\\"19\\\": {\\\"title\\\": \\\"Henry IV, Part 2\\\", \\\"finished\\\": 1598},\\\"20\\\": {\\\"title\\\": \\\"Much Ado About Nothing\\\", \\\"finished\\\": 1599},\\\"21\\\": {\\\"title\\\": \\\"Henry V\\\", \\\"finished\\\": 1599},\\\"22\\\": {\\\"title\\\": \\\"Julius Caesar\\\", \\\"finished\\\": 1599},\\\"23\\\": {\\\"title\\\": \\\"As You Like It\\\", \\\"finished\\\": 1600},\\\"24\\\": {\\\"title\\\": \\\"Hamlet\\\", \\\"finished\\\": 1601},\\\"25\\\": {\\\"title\\\": \\\"Twelfth Night\\\", \\\"finished\\\": 1601},\\\"26\\\": {\\\"title\\\": \\\"Troilus and Cressida\\\", \\\"finished\\\": 1602},\\\"27\\\": {\\\"title\\\": \\\"Sir Thomas More\\\", \\\"finished\\\": 1604},\\\"28\\\": {\\\"title\\\": \\\"Measure for Measure\\\", \\\"finished\\\": 1604},\\\"29\\\": {\\\"title\\\": \\\"Othello\\\", \\\"finished\\\": 1604},\\\"30\\\": {\\\"title\\\": \\\"All's Well That Ends Well\\\", \\\"finished\\\": 1605},\\\"31\\\": {\\\"title\\\": \\\"King Lear\\\", \\\"finished\\\": 1606},\\\"32\\\": {\\\"title\\\": \\\"Timon of Athens\\\", \\\"finished\\\": 1606},\\\"33\\\": {\\\"title\\\": \\\"Macbeth\\\", \\\"finished\\\": 1606},\\\"34\\\": {\\\"title\\\": \\\"Antony and Cleopatra\\\", \\\"finished\\\": 1606},\\\"35\\\": {\\\"title\\\": \\\"Pericles, Prince of Tyre\\\", \\\"finished\\\": 1608},\\\"36\\\": {\\\"title\\\": \\\"Coriolanus\\\", \\\"finished\\\": 1608},\\\"37\\\": {\\\"title\\\": \\\"The Winter's Tale\\\", \\\"finished\\\": 1611},\\\"38\\\": {\\\"title\\\": \\\"Cymbeline\\\", \\\"finished\\\": 1610},\\\"39\\\": {\\\"title\\\": \\\"The Tempest\\\", \\\"finished\\\": 1611},\\\"40\\\": {\\\"title\\\": \\\"Cardenio\\\", \\\"finished\\\": 1613},\\\"41\\\": {\\\"title\\\": \\\"Henry VIII\\\", \\\"finished\\\": 1613},\\\"42\\\": {\\\"title\\\": \\\"The Two Noble Kinsmen\\\", \\\"finished\\\": 1614}}}\");end;"},
"39":{"lang":"JA","title":"二人の貴公子","chapter":"N","answer":"^The Two Noble Kinsmen$","ok":"たいへんよいです","error":"","text":"<p>いいですね。インターネットから戯曲のリストを取得できました。リストはjsonフォーマットになっていました。\n幸いなことに、RubyはjsonデータをRubyのハッシュに変換するメソッドを提供しています。\n今回は、<em>get</em>shakey_メソッドがすでにそれをやってくれていました。</p>\n\n<p>ただ、ハッシュにはなりましたが、jsonデータの構造を保ち続けているためにちょっとばかり読みにくいです。\n戯曲のリストをいい感じに表示するメソッドを書いていきましょう。</p>\n\n<p>注意深く戯曲のリストを確認してみると、それがある種のネスト構造を持っていることに気がつくでしょう\n（こうしたことはインターネットから取得するデータには実際よくあることです）。以下のような感じです。</p>\n\n<ul>\n  <li>&ldquo;William Shakespeare&rdquo;\n  <ul>\n      <li>&ldquo;1&rdquo;\n      <ul>\n        <li>&ldquo;title&rdquo;: &ldquo;The Two Gentlemen of Veron&rdquo;</li>\n        <li>&ldquo;finished&rdquo;: 1591</li>\n      </ul>\n      </li>\n      <li>&ldquo;2&rdquo;\n      <ul>\n        <li>&ldquo;title&rdquo;: &ldquo;The Taming of the Shrew&rdquo;</li>\n        <li>&ldquo;finished&rdquo;: 1591</li>\n      </ul>\n      </li>\n      <li>&hellip;</li>\n  </ul>\n  </li>\n</ul>\n\n<p>戯曲をリストにするために、まずいちばん上の&quot;William Shakespeare&quot; というハッシュ要素に、名前を指定してアクセスする必要があります。\n次に、そこから下の要素を<strong>繰り返し</strong>ていきます。</p>\n\n<p>Rubyには繰り返していくためのメソッドがあります。それが<strong>each</strong>メソッドです。\nこのメソッドは書評システムを作成したときにも使いました。</p>\n\n<p><strong>each</strong>メソッドが返すものはすべて、次のようにブロックに渡されます。</p>\n\n<pre><code>s = get_shakey\n\ns[&quot;William Shakespeare&quot;].each { |key, val|\n  puts val[&quot;title&quot;]\n}\n</code></pre>\n","load_code":"prev"},
"40":{"lang":"JA","title":"すべてを一緒に","chapter":"N","answer":"^4$","ok":"そうです。シェイクスピアは1591年に4つの戯曲を書きました","error":"1591年の答えは4になります","text":"<p>ここで、ある年にシェイクスピアによって書かれた戯曲の数と名前のリストだけを知りたいとします。</p>\n\n<p>Rubyでは、ハッシュから値を選び出す(<strong>select</strong>)ことができます。\nselectメソッドは、選び出す条件をブロックとして渡すと、条件に該当した値のリストを返します。</p>\n\n<p><strong>select</strong>ブロックのあとにそのまま<strong>each</strong>ブロックをつなげることで、\nselectメソッドから返ったリストを使い、<strong>each</strong>メソッドを呼ぶことができます。\nこれはメソッド連鎖の別の例です。メソッド連鎖については、詩をひっくり返す際に軽くお話ししました。</p>\n\n<p>上記を行う<strong>count_plays</strong>メソッドを用意しました。\n以下のコードをもとに、<strong>1591</strong>年にシェイクスピアによってどのくらいの数の戯曲が書かれたかを調べてみてください。</p>\n\n<pre><code>def count_plays(year)\n  s = get_shakey\n\n  s[&quot;William Shakespeare&quot;]\n    .select { |k, v|\n      v[&quot;finished&quot;] == year\n    }.each { |key, val|\n      puts val[&quot;title&quot;]\n    }.count\nend\n\nputs count_plays(0)\n</code></pre>\n\n<p>countメソッドをeachメソッドの終わりにつなげていることに気づきましたか？\nこの値が<strong>count_plays</strong>メソッドの戻り値になります。</p>\n\n<p>メソッド連鎖のまた別の具体例を示します。<em>s = get</em>shakey__ という行を見てみてください。\nここで、get<em>shakeyのうしろに</em><em>[&ldquo;William Shakespeare&rdquo;].select { |k, v|</em>_ と続けることもできます\n（この場合はドットは付けないでください）。</p>\n","load_code":"prev"},
"41":{"lang":"JA","title":"終わりよければ全てよし","chapter":"N","answer":"All's Well That Ends Well","ok":"確かに","error":"2つ目の引数に1605を与えてください","text":"<p>いくつかのデータをインターネットから取得し、そこから欲しいものを選び出して出力しました。\nもっとよくするには、あと何が残っているでしょう？結果の表示をもう少しよくするとよいでしょうか。\nたとえば年を追加して、書名と年を揃えて表示するのはどうでしょう。</p>\n\n<p>これは、いくつかの値を1行に表示するということです。\nRubyにはそれをするためのきちんとした方法があります。\n<strong>puts &ldquo;Hi, my name is Jimmy&rdquo;</strong>のように、単なる文字列を表示するようなものです。\nですが、文字列リテラル<em>Jimmy</em>の代わりに、変数の値を使います。</p>\n\n<p>まず<strong>Jimmy</strong>を <strong>#{}</strong>に置き換えます。Rubyは波かっこがつづく#を見た場合は、{ かっこの中に変数を探します } 。つまり、次のように書くことができます。<strong>&ldquo;Hi, my name is #{name}&rdquo;</strong>。</p>\n\n<p>では、コードを少しばかり変更しましょう。</p>\n\n<pre><code>def print_plays(year_from, year_to)\n  get_shakey[&quot;William Shakespeare&quot;]\n    .select { |k, v|\n      year_from &lt;= v[&quot;finished&quot;] &amp;&amp;\n      year_to   &gt;= v[&quot;finished&quot;]\n    }.each { |k, v|\n      puts &quot;#{v[&quot;title&quot;].ljust(30)} #{v[&quot;finished&quot;]}&quot;\n    }\nend\nprint_plays(1600, 1605)\n</code></pre>\n\n<p>書名に<strong>.ljust(30)</strong>を追加しました。これによって書名は30文字の長さのなかで<em>左寄せ(left justified)</em>され、年の表示位置がいいかんじに整列されます。</p>\n\n<p>プログラムの出力が変更したことを確認したら、戯曲を表示する箇所を次のように変更してください。<strong>1600 -&gt; あなたの好きな値</strong></p>\n\n<p><strong>終わりよければ全てよし？</strong>いいえ、まだおしまいではありません。けれど、それはもう目前です！</p>\n","load_code":"prev"},
"42":{"lang":"JA","title":"意思決定の仕方について知っている唯一のこと","chapter":"N","answer":"","ok":"","error":"","text":"<p>意思決定、それは実際の暮らしでは実に厄介な問題です。まあ、私たちにとっては、そうでもないですが。\nRubyはいとも簡単に意思決定を行います。</p>\n\n<pre><code>if 1 &lt; 2\n  puts &quot;真: 1は2より小さい&quot;\nend\n</code></pre>\n\n<p>ここで鍵となる単語は<strong>if</strong>です。ifは、メソッドの前に配置することもできれば、\n次のように後ろにも配置できます。</p>\n\n<pre><code>puts &quot;真: 1は2より小さい&quot; if 1 &lt; 2\n</code></pre>\n\n<p><strong>if</strong>は引数を1つ持つメソッドです。その引数で、どんな任意の式もテストできます。\n式の結果はかならず<strong>true（真）</strong>か<strong>false（偽）</strong>でなければなりません。\n次に、こうした結果となるいくつかの式の例を示します。</p>\n\n<pre><code>5     &lt;= 10     # =&gt; true\n&#39;abc&#39; == &#39;def&#39;  # =&gt; false\ntrue            # =&gt; true\n123456          # =&gt; true\n0               # =&gt; true\nnil             # =&gt; false\n&#39;xyz&#39;.empty?    # =&gt; false\n&#39;a&#39; &gt; 5         # =&gt; エラー:\n                # 文字列と数値は比較できません\n</code></pre>\n\n<p><em>if式</em>は多くの形を取ることができます。リテラルの値同士（1 &lt; 2）を比較できます。\nまた、変数同士（a &lt; 1）を比較できます。\nそして、メソッドの戻り値（&#39;xyz&rsquo;.empty?）も扱えます。</p>\n","load_code":""},
"43":{"lang":"JA","title":"そしていよいよ終わりの始まり","chapter":"N","answer":"は100と等しくありません$","ok":"良くなりました","error":"正しくありません","text":"<p><strong>&lsquo;abc&rsquo; == &lsquo;def&rsquo;</strong>でイコール記号が2つあることに気づきましたか？</p>\n\n<p><strong>==</strong>は<strong>等しい</strong>という意味になります。\nイコール記号が1つしかない場合は、以前にやったとおり、<strong>変数に値を設定する</strong>という意味になります。</p>\n\n<p>より混乱させることになりますが、ifメソッドの後に変数への値の設定をすることもあります。\n次のようになります。</p>\n\n<pre><code>a = 0\n\nif a = 100\n  puts &quot;式はtrueです。けれど、aの値は#{a}となりました。&quot;\nelse\n  puts &quot;#{a}は100と等しくありません&quot;\nend\n</code></pre>\n\n<p>=を==に変更してどうなるかを確認してください。</p>\n\n<p>保証しますが、ことあるごとにあなたは二つ目のイコール記号を入力し忘れてしまうでしょう。\nいまだに私も忘れてしまうことがあります。</p>\n\n<h3>else</h3>\n\n<p>先ほどのコードで、else式を追加しました。\nこの箇所は<strong>if テストする式</strong>がfalseと評価した際に実行されることになります。</p>\n\n<blockquote>\n<p>このif-then-elseの書き方には、もっとたくさんのバリエーションがあります。\n詳しく知りたい方は<a href=\"http://www.ruby-doc.org/core/doc/syntax/control_expressions_rdoc.html\" target=\"_blank\">ここ</a>を読んでください。</p>\n</blockquote>\n","load_code":""},
"44":{"lang":"JA","title":"腹ペコです","chapter":"N","answer":"^腹ペコじゃないです$","ok":"はい","error":"まさか10時にはお腹は空きませんよ！","text":"<p>さて、ここまではとても順調に行っています。簡単だと感じたかもしれませんが、\nたった15分前までは<strong>Rubyがいかなるものか</strong>何も知らなかったことを覚えておいてください！</p>\n\n<p>最後のステップです。ぜんぶを一つにしていきましょう。いいですか？\n眩しい日差しの中、浜辺で光り輝くウィンドチャイムの響きのように、\nこれまでやってきたことを調和させ、美しく奏でましょう！</p>\n\n<p>まず2つのメソッドを定義し、次に判定を行います。</p>\n\n<pre><code>def hungry?(time_of_day_in_hours)\n  puts &quot;腹ペコです&quot;\n  true\nend\n\ndef eat_an(what)\n  puts &quot;#{what}を食べます\\n&quot;\nend\n\neat_an &#39;リンゴ&#39; if hungry?(14)\n\neat_an &#39;リンゴ&#39; if hungry?(10)\n</code></pre>\n\n<p><strong>hungry?</strong>メソッドを、時間(引数で渡された値）が12未満だった場合に\n<strong>&ldquo;腹ペコじゃないです&rdquo;</strong>と表示してfalseを返すように変更できるか確かめてみてください。</p>\n","load_code":""},
"45":{"lang":"JA","title":"要約（その6）まで来ました","chapter":"Y","answer":"\\{\\}","ok":"そうです。それが空のハッシュです","error":"","text":"<p>あなたはレベル6のRuby聖職者です。偉大な仕事を為しました。確認していきましょう。</p>\n\n<h3>データ</h3>\n\n<p>インターネットからデータを読み込み、データ構造に変換し、値を選び出しました。</p>\n\n<h3>繰り返し</h3>\n\n<p>ハッシュのすべての要素を繰り返し取り出し、さらにメソッドを連鎖させました。</p>\n\n<h3>プリティプリント</h3>\n\n<p>そして手に入った値が十分ではなかったので、人が読みやすい形に書式を整え、値を表示させました。\nつまり、<strong>現実のプログラムを作りました！</strong></p>\n\n<h3>if</h3>\n\n<p>プログラムを<strong>if</strong>文と<strong>else</strong>文を使って制御する方法を学びました。</p>\n\n<h2>そして</h2>\n\n<p>次は何でしょう？ここからは何を学ぶ必要があるでしょうか？\nこれからが一番いいところです。\nあなたが進んできたのは、私たちがクラスを発見するまで辿ってきた長い道のりのようなものです。\nあと2つ、ここまで程は長くないレッスンをやれば、おしまいです。</p>\n\n<p>以前、次のようなハッシュを作成しました。</p>\n\n<pre><code>Hash.new\n</code></pre>\n","load_code":""},
"46":{"lang":"JA","title":"学生ではなく、労働者","chapter":"N","answer":"","ok":"","error":"","text":"<p>先ほど確認した空の波かっこ{}は、Hash.newのショートカットです。\nnewメソッドは特定のクラスのオブジェクトを作成するために使われます。\n「クラス（class）」とは「労働者（working class）」 &mdash; \n同じ仕事を持ち、同じシャツを着た、似たようなオブジェクトの集まりのようなものだと考えてください。\nクラスはどのように使うのでしょうか？</p>\n\n<h3>Blurbalizer<sup>TM</sup></h3>\n\n<p>新しいアプリに関する素晴らしいアイデアを思いついたとします。\nそれは、次世代のインスタントメッセージプラットフォームになるでしょう。\nアプリが扱うメッセージのことはBlurbs<sup>TM</sup>と呼ぶことにします。\nBlurbs<sup>TM</sup>の長さは最大でたった40文字です。\nそこに気分もつけられるようにしましょう。</p>\n\n<!---インターネットは失墜した棒人間と顔文字を本当に持ち帰ってきました。__顔文字！__ -->\n\n<h3>スタート地点</h3>\n\n<p>さて、あなたはJSONファイルにBlurbs<sup>TM</sup>のエントリを格納するでしょうか。あってます？\nでも、どうやって投稿された時刻とエントリの中身を記録しますか？\nそしてファイルを読み込んだ中身は、Rubyではどのように扱えるでしょう？\nハッシュか、それとも配列でしょうか？あるいは配列の配列？もしくは他の何か？</p>\n\n<h3>クラス</h3>\n\n<p>おそらく、あなたはクラスを使いたくなるはずです。\nあなたはすでに、たくさんのクラスと馴染んでいます。HashやArray、Stringなどです。\nでは、（何も出力しない）新しいクラスを作りましょう。</p>\n\n<pre><code>class Blurb\nend\n</code></pre>\n","load_code":""},
"47":{"lang":"JA","title":"アプリを作るもの","chapter":"N","answer":"","ok":"","error":"","text":"<p>新しくBlurb<sup>TM</sup>クラスを開きました。\nブログエントリは一体何で作られるでしょう？そうです、コンテンツです。\nそれからBlurb<sup>TM</sup>が投稿された時刻、そして気分も必要でしょう。</p>\n\n<p>先ほどはクラスの最初の行を用意しました。以下が残りの部分になります。</p>\n\n<pre><code>class Blurb\n  attr_accessor :content, :time, :mood\nend\n</code></pre>\n\n<p>クラス名は常に大文字から始まります。</p>\n\n<p>（まだ何も出力しません）</p>\n","load_code":""},
"48":{"lang":"JA","title":"アクセサはぶらぶらとした手","chapter":"N","answer":"Blurb:","ok":"はじめての手","error":"","text":"<p>なかなか素質がありますね。これで、新しいBlurb<sup>TM</sup>クラスを手に入れました。</p>\n\n<p>クラス定義の中で、attr_accessorと呼ばれるメソッドを使いました。\nこうした属性(<em>attr</em>ibute)メソッドの多くは、クラスにわずかばかりの設定を加えます。\nこれらの属性は、ちょうどクラスに付属する変数のようなものです。</p>\n\n<p>これがどういうことかを考えてみます。\nクラスは人のようなものです。星型の人を想像してください。\nそして属性は、体を構成し他の人との握手も可能にする、ぶらぶらとした手です。</p>\n\n<h3>ここから</h3>\n\n<p>Blurb<sup>TM</sup>を生成して、コンテンツを設定するために、以下のようにしてください。</p>\n\n<pre><code>blurb1 = Blurb.new\nputs blurb1\nblurb1.content = &quot;Today Mount Hood Was Stolen!&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :content,:time,:mood;end"},
"49":{"lang":"JA","title":"オブジェクトとは、キチンとした小さなパッケージ","chapter":"N","answer":"Blurb:","ok":"Blurbを更新しました","error":"","text":"<p>先に進み、Blurb<sup>TM</sup>に時刻と気分を設定してください。</p>\n\n<pre><code>blurb1.time = Time.now\nblurb1.mood = :sick\n\nputs blurb1\n</code></pre>\n","load_code":"prev;blurb1=Blurb.new;blurb1.content=\"Today Mount Hood Was Stolen!\""},
"50":{"lang":"JA","title":"ペースを速めて","chapter":"N","answer":"^\\d{4}","ok":"記録されました","error":"","text":"<p>いい感じです。じゃあ、ちょっとだけ軽く何か作ってみましょう。\nBlurb<sup>TM</sup>するごとに毎回時間を設定したくはないでしょう。</p>\n\n<p>内容の入力と気分の選択だけしたいですよね？</p>\n\n<p><strong>initialize</strong>メソッドをクラスに追加しましょう。\nこのメソッドは新しいBlurb<sup>TM</sup>がつくられるたびに呼び出されます。\n同時に、Blurb<sup>TM</sup>の内容を40文字に制限することもできます。</p>\n\n<pre><code>class Blurb\n  attr_accessor :content, :time, :mood\n\n  def initialize(mood, content=&quot;&quot;)\n    @time    = Time.now\n    @content = content[0..39]\n    @mood    = mood\n  end\nend\n\nBlurb.new.time\n</code></pre>\n\n<p>（引数の<strong>content=&ldquo;&rdquo;</strong>という部分は、内容が文字列であると確認するためにあります。\nこう書くことで、たとえcontent部分の引数が与えられなったとしても空文字が渡されます。）</p>\n","load_code":""},
"51":{"lang":"JA","title":"意味ないものは拒むようにしつけました","chapter":"N","answer":"Blurb:","ok":"Blurbが追加されました","error":"","text":"<p>クラスの内側がどうなっているかを確認し、アットマークが付いたシンボル(@time)を使いました。</p>\n\n<p>クラスの<strong>外側</strong>では、アクセサを使います。</p>\n\n<blockquote>\n<p><strong>blurb.time = Time.now</strong></p>\n</blockquote>\n\n<p>ですが、<strong>内側</strong>では<strong>オブジェクトの変数</strong>を使います。</p>\n\n<blockquote>\n<p><strong>@time = Time.now</strong></p>\n</blockquote>\n\n<p>これらは実際には同じことです。しかしプログラムの2つの異なる場所では異なる表現を使います。</p>\n\n<h3>別のBlurb<sup>TM</sup>を作る</h3>\n\n<p>新しいBlurb<sup>TM</sup>を作成すると、initializeメソッドは新しい任意の引数用に使われます。</p>\n\n<p>あ、2つの引数が必要です。</p>\n\n<pre><code>Blurb2 = Blurb.new :confused, &quot;I can not believe Mt. Hood was stolen!&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :content,:time,:mood;def initialize(mood, content=\"\");@time=Time.now;@content=content[0..39];@mood=mood;end;end;blurb1=Blurb.new(:sick,\"Today Mount Hood Was Stolen!\")"},
"52":{"lang":"JA","title":"キリンは要約（その7）を盗みません","chapter":"Y","answer":"","ok":"","error":"","text":"<p>やっと、ここまできました。すべてを1つにしました。まだアプリを現実に近づけるつもりですが、その前にやったことを振り返りましょう。いいですか？</p>\n\n<h3>クラス</h3>\n\n<p>Rubyのすべてはオブジェクトです。クラスはオブジェクトを説明するもので、特定のオブジェクトがどう動くかを説明します。\n例えば、いくつか新しいBlurb<sup>TM</sup>オブジェクトを作成したとすると、それらのオブジェクトはクラスによって説明されたということです。\nつまり、それらはBlubオブジェクトです。\nクラスを（ある種）現実世界のオブジェクトのモデルとして使うことができます。</p>\n\n<h3>アクセサ</h3>\n\n<p>アクセサは、オブジェクトの<strong>外</strong>から使うことのできる、オブジェクトに付けられた変数です。\n（blurb2.time = Time.now）</p>\n\n<h3>オブジェクトの変数</h3>\n\n<p>オブジェクト変数はアクセサで触れる変数と同じです。けれど、オブジェクトの<strong>内側</strong>にあります。\n（@time = Time.now）</p>\n","load_code":"prev;blurb2=Blurb.new :confused, \"I can not believe Mt. Hood was stolen!\""},
"53":{"lang":"JA","title":"あなた自身の芝","chapter":"N","answer":"Blurbalizer:","ok":"アプリが作られました","error":"","text":"<p>さて、全部をまとめ上げましょう。ここからがTry Rubyの魅惑的な壮大なストーリーの最後の章です！\n今やあなたはすべての機能を堪能しました。\n家の周りやあなたが経営する食料品店の冷蔵庫の中で、どうそれを使うつもりですか？\nあなたは（私のお気に入りの）偉大な人物ではありますが、ガイドは必要です。</p>\n\n<h3>アプリケーションを完成させましょう</h3>\n\n<p>あなたはアプリの要素は持っています。\nけれど実際のアプリではありません。\nタイトルやすべてのBlurbs<sup>TM</sup>を格納する場所、順序通りのタイムラインなどが必要です。</p>\n\n<p>推測したとおり、これから新しい別のクラスを作ります。\n新しいクラスのためのコードを全て一度に提供します。\nぜんぜん勉強に<strong>時間をかけてかまいませんよ</strong>。\n私は急ぎませんよ。次のレッスンにあなたが来るのを待っています。</p>\n\n<pre><code>class Blurbalizer\n  def initialize(title)\n    @title  = title\n    @blurbs = [] # A fresh clean array\n                 # for storing Blurbs\n  end\n\n  def add_a_blurb(mood, content)\n    # The &lt;&lt; means add to the end of the array\n    @blurbs &lt;&lt; Blurb.new(mood, content)\n  end\n\n  def show_timeline\n    puts &quot;Blurbify: #{@title} has #{@blurbs.count} Blurbs&quot;\n\n    @blurbs.sort_by { |t|\n      t.time\n    }.reverse.each { |t|\n      puts &quot;#{t.content.ljust(40)} #{t.time}&quot;\n    }\n  end\nend\n\nmyapp = Blurbalizer.new &quot;The Big Blurb&quot;\n</code></pre>\n","load_code":"class Blurb;attr_accessor :content,:time,:mood;def initialize(mood, content=\"\");@time=Time.now;@content=content[0..39];@mood=mood;end;end"},
"54":{"lang":"JA","title":"あのBlurbは何のこと？","chapter":"N","answer":"Today","ok":"Blurbをもたらしました","error":"","text":"<p>その調子です。Blurbalizer<sup>TM</sup>クラスの中のコードがどんなことをしているか理解しましたか？</p>\n\n<blockquote>\n<p>Blurbalizer<sup>TM</sup>クラスには2つの<strong>メソッド</strong>（add_a_blurbとshow_timeline）があります。\nアクセサと同じように、これらのメソッドはクラスの外側で使用できます。</p>\n</blockquote>\n\n<p>Blurbalizer<sup>TM</sup>を使うときです。すでにいくつかのBlurb<sup>TM</sup>を読み込んであります。\nですが、あなた自身の手でもBlurbを自由に追加してみてください。</p>\n\n<p>Blurb<sup>TM</sup>は直接作成せず、Blurbalizer<sup>TM</sup>クラスのadd_a_blurbメソッドを使って作成します。これによって、すべてのBlurb<sup>TM</sup>がmyappオブジェクトの中に格納されていることを確認できます。</p>\n\n<pre><code>myapp.add_a_blurb :moody, &quot;ここにBlurbを追加します&quot;\n\nmyapp.show_timeline\n</code></pre>\n","load_code":"prev;class Blurbalizer;attr_reader :title;def initialize(title);@title=title;@blurbs=[];end;def add_a_blurb(mood, content);@blurbs << Blurb.new(mood, content);@blurbs.each {|t| t.time -= 73};end;def show_timeline;puts \"Blurbalizer: #{@title} has #{@blurbs.count} Blurbs\\n\";@blurbs.sort_by { |t| t.time}.reverse.each { |t| puts \"#{t.content.ljust(40)} #{t.time}\"};end;end;myapp = Blurbalizer.new \"The Big Blurb\";myapp.add_a_blurb :sick,\"Today Mount Hood Was Stolen!\";myapp.add_a_blurb :confused,\"I can not believe Mt. Hood was stolen!\";myapp.add_a_blurb :dazed,\"I am speechless!\";myapp.add_a_blurb :mad,\"It was stolen by a giraffe !!\";myapp.add_a_blurb :sad,\"I Left my Hoodie on the Mountain!\";myapp.add_a_blurb :mad,\"I am never going back to that mountain.\""},
"55":{"lang":"JA","title":"すべてを繋ぎ合わせます","chapter":"N","answer":":-","ok":"気分いい！","error":"","text":"<p>Rubyのシンプルな部品を使うと、とりわけ新しいものに部品をつなぎ合わせる際、\nいくらか美しいものにすることが可能です。\nここで別のクラスを含むクラスで作られたアプリを作ったように、\nRubyはある種の人間にとって本当に良いことをします。\nそれはオブジェクト指向プログラミングと呼ばれます。</p>\n\n<p>TryRubyの<strong>最後のプログラミングの訓練</strong>にたどり着きました。\nやってみたければ、あたらしい機能をBlurbalizer<sup>TM</sup>に追加できます。</p>\n\n<p>おそらく、<strong>show_timeline</strong>メソッドの中に顔文字として気分を出力したいでしょう。\n<em>moodify</em>メソッドをBlurb<sup>TM</sup>に追加し、<em>show_timeline</em>メソッド内で使います。</p>\n\n<pre><code>class Blurb\n  attr_accessor :content, :time, :mood\n\n  def initialize(mood, content=&quot;&quot;)\n    @time    = Time.now\n    @content = content[0..39]\n    @mood    = mood\n  end\n\n  def moodify\n    if    @mood == :sad\n      return &quot;:-(&quot;\n    elsif @mood == :happy\n      return &quot;:-)&quot;\n    # Add other moods here\n    end\n\n    # The default mood\n    &quot;:-|&quot;\n  end\nend\n\nclass Blurbalizer\n  def initialize(title)\n    @title  = title\n    @blurbs = []\n  end\n\n  def add_a_blurb(mood, content)\n    @blurbs &lt;&lt; Blurb.new(mood, content)\n  end\n\n  def show_timeline\n    puts &quot;Blurbalizer: #{@title} has #{@blurbs.count} Blurbs&quot;\n\n    @blurbs.sort_by { |t|\n      t.time\n    }.reverse.each { |t|\n      puts &quot;#{t.content.ljust(40)} #{t.time}&quot;\n    }\n  end\nend\n\nmyapp.show_timeline\n</code></pre>\n","load_code":"prev"},
"56":{"lang":"JA","title":"要約（その8）です。リラックスして聞いてください","chapter":"Y","answer":"","ok":"","error":"","text":"<p>この最後の章は幕を閉じ、Rubyをどう使えるかについていくつかのポインタを示すためにあります。</p>\n\n<p>ここまで楽しめたなら、<a href=\"/playground\">TryRuby Playground</a>で続けることもできますし、\nRubyをダウンロードしてインストールすることもできます。\n<a href=\"https://www.ruby-lang.org/ja/downloads/\" target=\"_blank\">ruby-lang.org</a></p>\n\n<p>Rubyをインストールしたなら、_my_first_program.rb というファイルを作成し、\nテキストエディタでファイルを開いて、適当なRubyコードを書いて実行してみてください。\nプログラムを実行するには、コマンドプロンプトを開き、次のように入力します。</p>\n\n<pre><code>ruby my_first_program.rb\n</code></pre>\n\n<p>エディタとファイルブラウザ、&#39;ruby-runner&#39;などが一つになった、\nたくさんの（フリーな）開発ツールが存在しています。</p>\n\n<h2>おめでとうございます</h2>\n\n<p>あなたは、何度も砂糖衣をかけた二層ケーキや、ダブルギターを弾くギタープレイヤーに本当に値します。\nつまり終わったということです。本当にやり遂げました！疑いようがありません。\nこれであなたは<strong>認定元気いっぱい利口者</strong>です！</p>\n\n<h2>もっと情報が欲しいなら</h2>\n\n<p>このウェブサイトにいくつか記事があります。\nそれらを読めばここから先どこに行けばいいかのポインタをいくつか手に入れられます。</p>\n","load_code":"def ruby(f);puts \"www.ruby-lang.orgに行ってRubyをダウンロードしましょう\";end;class K;attr_reader :rb;end;my_first_program=K.new"}}